<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[[LeetCode]2 Add Two Numbers/两数相加]]></title>
    <url>%2F2018%2F09%2F10%2FLeetCode-2-Add-Two-Numbers-%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0%2F</url>
    <content type="text"><![CDATA[★★ Add Two Numbers You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list. You may assume the two numbers do not contain any leading zero, except the number 0 itself. 两数相加 给定两个非空链表来表示两个非负整数。位数按照逆序方式存储，它们的每个节点只存储单个数字。将两数相加返回一个新的链表。 你可以假设除了数字 0 之外，这两个数字都不会以零开头。 123输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)输出：7 -&gt; 0 -&gt; 8原因：342 + 465 = 807 从前往后加，主要是进位。 Java 12345678910111213141516171819public class Solution &#123; public ListNode addTwoNumbers(ListNode l1, ListNode l2) &#123; ListNode dummy = new ListNode(-1); ListNode cur = dummy; int carry = 0; while (l1 != null || l2 != null) &#123; int d1 = l1 == null ? 0 : l1.val; int d2 = l2 == null ? 0 : l2.val; int sum = d1 + d2 + carry; carry = sum &gt;= 10 ? 1 : 0; cur.next = new ListNode(sum % 10); cur = cur.next; if (l1 != null) l1 = l1.next; if (l2 != null) l2 = l2.next; &#125; if (carry == 1) cur.next = new ListNode(1); return dummy.next; &#125;&#125; C++ 1234567891011121314151617181920212223242526272829/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* addTwoNumbers(ListNode* l1, ListNode* l2)&#123; int carry = 0;//进位 ListNode* result = new ListNode(-1); ListNode* cur = result; while(l1 || l2)&#123; int n1 = l1 ? l1-&gt;val : 0;//如果l1没有数值了，为0 int n2 = l2 ? l2-&gt;val : 0; int sum = n1 + n2 + carry; carry = sum / 10; cur-&gt;next = new ListNode(sum % 10); cur = cur-&gt;next; if(l1) l1 = l1-&gt;next; if(l2) l2 = l2-&gt;next; &#125; if(carry) cur-&gt;next = new ListNode(1); return result-&gt;next;//△ &#125;&#125;; 感觉隔了很久 最近堕落了（￣～￣）]]></content>
      <tags>
        <tag>study</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[随笔2]]></title>
    <url>%2F2018%2F09%2F08%2F%E9%9A%8F%E7%AC%942%2F</url>
    <content type="text"><![CDATA[之前为了推免，努力看书，结果笔试面试啥都没考(▼ヘ▼#) 所以整理了一半，以后补全吧，正好自己也回顾总结一下，以后复习也方便。 近期目标： 要学习机器学习和数据挖掘，整理一下这部分的内容。加点实验内容。 还要多写代码，leetcode进度跟上。主要是C++。 要练习英语，开始看论文。 python。 最近迷上了yusa，yusa赛高，可是有很多都是生肉，听不懂真的好气啊，于是暗搓搓下决心，一定要学日语。 就这样。φ(&gt;ω&lt;*)]]></content>
      <tags>
        <tag>7788</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Database]]></title>
    <url>%2F2018%2F08%2F16%2FDatabase%2F</url>
    <content type="text"><![CDATA[chapter1 基本概念 关系数据库，是创建在关系模型基础上的数据库，借助于集合代数等数学概念和方法来处理数据库中的数据。现实世界中的各种实体以及实体之间的各种联系均用关系模型来表示。 关系模型由关系数据结构、关系操作集合、关系完整性约束三部分组成。 数据：data，描述事物的符号记录；数据粒度：字段、记录、表；字段的复杂数据类型：结构、数组、集合。 数据库：DB，存贮介质，长期储存，有一定组织形式，可共享；数据模型：较小的冗余度，独立性，易扩展性，共享。 数据库管理系统：DBMS，介于用户与操作系统之间的数据管理软件系统。 数据库系统：DBS，由数据库、数据库管理系统、应用程序、数据库管理员、用户组成。 数据库管理员：DBA，数据库设计、规划、协调的人员，最高特权的用户。 实例：特定时刻存储在数据库中的信息的集合。 模式：数据库的总体设计。 数据模型：四要素：结构、联系、操作、约束。 数据定义语言：DDL，定义了数据库模式的实现细节。 数据操纵语言：DML，使得用户可以访问或操纵那些按照某种适当的数据模型组织起来的数据。过程化DML：要求用户指需要什么数据以及如何获得这些数据；声明式DML：只要求用户指定需要什么数据； 数据库设计：DBS规划，DB设计，DB建立，DB应用程序设计，DB运行、管理、维护，DB扩充、重构 实体-联系模型：E-R，使用一组称为实体的基本对象，以及这些对象间的联系。数据库中实体通过属性集合来描述。联系时几个实体之间的关联。 chapter2 关系数据库 关系：二维表，由关系名标识 元组：表中的一行，记录，n元组 属性：表中的一列，属性名标识，字段 域：属性的取值范围 码：能够唯一确定一个元组的最小属性集//最小，可以唯一区分。 超码：包含码的属性集，可以是我们在一个关系中唯一地标识一个元组 候选码：一个关系的每个码都称候选码 主码：定义表时指定一个候选码 外码：本关系的属性集，另一关系的码 全码：表中找不出码，所有属性组成 主属性：任一候选码中的属性 非主属性：不在任何一个候选码中 一个含有主码和外码依赖的数据库模式可以用模式图来表示。 关系代数：基于集合运算表示表的操作，过程化 关系演算：基于谓词逻辑表示表的操作，非过程化 SQL：商用语言，基于集合运算，非过程化与过程化的结合 chapter3 SQL char, vachar, int, smallint, numeric, real, double precision, float 12345678910111213create table department (dept_name varchar (20), building varchar (15), budget numeric (12, 2), primary key (dept_name)); insert into instructor values (&apos;..&apos;,&apos;..&apos;,..); delete from ..drop table..alter table .. add/drop ..select .. from .. where .. order by .. primary key：主码，主码属性必须非空且唯一 foreign key (..) references chapter4 中级SQL 连接：（1）外连接：①左外连接，只保留出现在左外连接运算之前的关系中的元组。②右外连接， 只保留出现在右外连接运算之后的关系中的元组。③全外连接，保留出现在两个关系中的元组。（2）内连接 chapter5 高级SQL 触发器：是一条语句，当对数据库作修改时，它自动被系统执行。要设置触发器机制，必须满足两个要求：指明什么条件下执行触发器。指明触发器执行时的动作。 OLAP span id=”jump6”&gt;chapter6 形式化关系查询语言 关系代数基本运算：选择、投影、并、集合差、笛卡尔积、更名]]></content>
      <tags>
        <tag>study</tag>
        <tag>database</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Data Structures]]></title>
    <url>%2F2018%2F08%2F13%2FData-Structures%2F</url>
    <content type="text"><![CDATA[introduction: 目录 chapter1 C++回顾 chapter2 程序性能分析 chapter3 渐近记法 chapter4 性能测量 chapter5 线性表——数组描述 chapter6 线性表——链式描述 chapter7 数组和矩阵 chapter8 栈 chapter9 队列 chapter10 跳表和散列 chapter11 二叉树和其他树 chapter12 优先级队列 chapter14 搜索树 chapter15 平衡搜索树 chapter16 图 chapter17 贪婪算法 chapter18 分而治之 chapter19 动态规划 选择排序，及时终止的选择排序 冒泡排序，及时终止的冒泡排序 名次排序 原地重排 插入排序 箱子排序 基数排序 堆排序 归并排序 chapter1 C++回顾 递归函数f：自己调用自己。直接递归，f包含了调用f的语句。间接递归，f调用了g，g调用了h，..，又调用了f。 递归函数 = 基础部分 + 递归部分。 斐波那契数列：F0=0，F1=1，Fn=F(n-1)+F(n-2)。 标准模板库STL： chapter2 程序性能分析 程序性能：运行这个程序所需要的内存和时间的多少。性能分析时采用分析方法，性能测量时采用实验方法。 空间复杂度：该程序的运行所需内存的大小。组成：指令空间，数据空间，环境栈空间。一个程序所需空间=固定部分+可变部分=c+Sp。集中计算Sp。 时间复杂度：编译时间，运行时间。主要关注运行时间。方法：（1）找出一个或多个关键操作，确定它们的执行时间（操作计数）。（2）确定程序总的步数。 操作计数：选择一种或多种关键操作（+×），确定每一种操作的执行次数。 步数：一个语法或语义上的程序片段，该片段执行时间独立于实例特征。 chapter3 渐近记法 大O记法：p(n)，q(n)两个非负函数，称p(n)渐近地大于q(n)，当且仅当lim q(n)/p(n)=0；称q(n)渐近地小于p(n)，当且仅当p(n)渐近地大于q(n)。称p(n)渐近地等于q(n)，当且仅当任何一个都不是渐近地大于另一个。 大O记法：f(n)=O(g(n))，当且仅当存在常数c&gt;0和n0，使得对于所有的n&gt;=n0，有f(n)&lt;=cg(n)。g(n)是f(n)的上界。 渐近记法Ω：f(n)=Ω(g(n))表示f(n)渐近大于或等于g(n)。f(n)=Ω(g(n))当且仅当存在常数c&gt;0和n0，使得对所有的n&gt;=n0，有f(n)&gt;=cg(n)。g(n)是f(n)的下界。 θ记法：f(n)=θ(g(n))，当且仅当存在常数c1&gt;0，c2&gt;0和n0，使得对于所有的n&gt;=n0，有c1g(n)&lt;=f(n)&lt;=c2g(n)。用来表示f的上限和下限都是一个函数的情况。 小o记法：f(n)=o(g(n))，当且仅当f(n)=Og(n)且f(n)≠Ω(g(n)) chapter4 性能测量 chapter5 线性表——数组描述 数据对象：一组实例或值（原子或复合） 数据结构：一个数据对象，同时这个对象的实例以及构成实例的元素都存在着联系，而且这些联系有相关的函数来规定。 线性表：linear list，有序表，每一个实例的形式为(e0,e1,..,en-1)，ei是元素，i是索引，n是长度或大小。 数组描述/公式化描述/顺序存储： （1）位置映射：location(i)=i；从后往前：location(i)=arrayLength-i-1；环绕：location(i)=(location(0)+i)%arrayLength； （2）变长一维数组：一个新长度的数组，把原数组的元素复制到新数组，最后改变原数组的值。 （3）arrayList： 1234checkIndex(int theIndex) //检查索引不越界 if(theIndex&lt;0 || theIndex&gt;=listSize) throw illeagalIndex(..); 1234get(int theIndex) //返回索引为theIndex的元素 checkIndex(theIndex); return element[theIndex]; 1234567indexOf(const T&amp; theElement) //返回元素theElement第一次出现的索引 int theIndex = (int) (find(element, element+listSize, theElement) - element); if(theIndex == listSize) return -1 else return theIndex; 12345earse(int theIndex) //删除索引为theIndex的元素 checkIndex(theIndex); copy(element+theIndex+1, element+listSize, element+theIndex); elemnt[--listSize].~T(); 123456789insert(int theIndex, const T&amp; theElement) //在索引theIndex处插入元素theElement check(theIndex); if(listSize == arrayLength) changeLength1D(element, arrayLenghth, 2*arrayLength); arrayLength *= 2; copy_backward(element+theIndex, element+listSize, element+listSize+1)；//向右移动一个 element[theIndex] = theElement; listSize++; （4）迭代器 123for(int* y=x; y!=x+3; y++)&#123; cout&lt;&lt;*y&lt;&lt;" "&lt;&lt;endl;&#125; （5）arrayList的迭代器 123class iterator;iterator begin() &#123;return iterator(element);&#125;iterator end() &#123;return iterator(element+listSize);&#125; vector 多重表 chapter6 线性表——链式描述 单向链表：每个节点只有一个链 12345678910template &lt;class T&gt;struct chainNode&#123; T element; chainNode&lt;T&gt; *next; chainNode() &#123;&#125; chainNode(const T&amp; element)&#123;this-&gt;element = element;&#125; chainNode(const T&amp; element, chainNode&lt;T&gt;* next) &#123;this-&gt;element = element; this-&gt;next = next;&#125;&#125;; 12345678get(int theIndex) const //返回索引为theIndex的元素 checkIndex(theIndex); chainNode&lt;T&gt;* currentNode = firstNode; for(int i=0; i&lt;theIndex; i++)&#123; currentNode = currentNode-&gt;next; return currentNode-&gt;element; &#125; 12345678910111213indexOf(const T&amp; theElement) const //返回元素theElement首次出现时的索引 chainNode&lt;T&gt;* currentNode = firstNode; int index = 0; while(currentNode != NULL &amp;&amp; currentNode-&gt;element != theElement)&#123; currentNode = currentNode-&gt;next; index++; &#125; if(currentNode == NULL) return -1; else return index; 1234567891011121314151617erase(int theIndex) //删除索引为theIndex的元素 checkIndex(theIndex); chainNode&lt;T&gt;* deleteNode; if(theIndex == 0)&#123; deleteNode = firstNode; firstNode = firstNode-&gt;next; &#125;else&#123; chainNode&lt;T&gt;* p = firstNode; for(int i=0; i&lt;theIndex-1; i++)&#123; p = p-&gt;next; &#125; deleteNode = p-&gt;next; p-&gt;next = p-&gt;next-&gt;next; &#125; listSize--; delete deleteNode; 12345678910111213insert(int theIndex, const T&amp; theElement) //在索引为theIndex处插入元素theElement checkIndex(theIndex); if(theIndex == 0)&#123; firstNode = new chainNode&lt;T&gt;(theElement, firstNode); &#125;else&#123; chainNode&lt;T&gt;* p = firstNode; for(int i=0; i&lt;theIndex-1; i++)&#123; p = p-&gt;next; &#125; p-&gt;next = new chainNode&lt;T&gt;(theElement, p-&gt;next); &#125; listSize++; iterator extendedChain：lastNode 12345678clear() //删除链表所有节点 while(firstNode != NULL)&#123; chainNode&lt;T&gt;* nextNode = firstNode-&gt;next; delete firstNode; firstNode = nextNode; &#125; listSize = 0; 12345678910push_back(const T&amp; theElement) //在链表尾端插入元素theElement元素 chainNode&lt;T&gt;* newNode = new chainNode&lt;T&gt;(theELment, NULL); if(firstNode == NULL) firstNode = lastNode = newNode; else&#123; lastNode-&gt;next = newNode; lastNode = newNode; &#125; listSize++; 循环链表：将单向链表的头结点和尾节点连接起来。使用头结点。 12345678910111213indexOf(const T&amp; theElment) const //返回元素theElement首次出现的索引 headerNode-&gt;element = theElement; chainNode&lt;T&gt;* currentNode = headerNode-&gt;next; int index = 0; while(currentNode-&gt;element != theElement)&#123; currentNode = currentNode-&gt;next; index++; &#125; if(currentNode == headerNode) return -1; else return index; 双向链表：next指向右边节点，previous指向左边节点。 箱子排序 基数排序 凸包 并查集：（1）等价类，等价关系 当且仅当 自反，对称，传递。相互等价的元素的最大集合。（2）离线等价类，已知n和R，确定等价类，每个元素只能属于一个等价类。（3）在线等价类，初始n，每个元素都属于一个等价类，需要combine和find。 12345classA = find(A);classB = find(B);if(classA != classB)&#123; unite(classA, classB);&#125; chapter7 数组和矩阵 行主映射：map(i1, i2) = i1u2+i2；u2是数组的列数；列主映射：map(i1, i2) = u1i2+i1； 矩阵： 1234567891011operator=(const matrix&lt;T&gt; m)&#123; //赋值 (*this) = m if(this != &amp;m)&#123; delete [] element; theRows = m.theRows; theColumns = m.theColumns; element = new T [theRows*theColumns]; copy(m.element, m.element+theRows*theColumns, element); &#125; return *this;&#125; 123456operator() (int i, int j) const&#123; //返回元素element(i,j)的引用 if(...) //检测越界 return element[(i-1)*theColumns+j-1];&#125; 12345678910operator+(const matrix&lt;T&gt;&amp; m) const&#123; //返回矩阵w = (*this)+m if(..) //检测 matrix&lt;T&gt; w(theRows, theColunns); for(int i=0; i&lt;theRows*theColumns; i++)&#123; w.element[i] = element[i]+m.element[i]; &#125; return w;&#125; 1234567891011121314151617181920212223operator* (const matrix&lt;T&gt;&amp; m) const&#123; if(..) //检测 matrix&lt;T&gt; w(theRows, m.theColumns); int ct=0, cm=0, cw=0; for(int i=1; i&lt;=theRows; i++)&#123; //结果矩阵第i行 for(int j=1; j&lt;=m.theColumns; j++)&#123; T sum = element[ct]*m.element[cm]; for(int k=2; k&lt;=theColumns; k++)&#123; ct++; cm += m.theColumns; sum += element[ct]*m.element[cm]; &#125; w.element[cw++] = sum; ct -= theColumns-1; cm = j; &#125; ct += theColumns; cm = 0; &#125; return w;&#125; 对角矩阵： 三对角矩阵：i=j，i=j+1，i=j-1. 对称矩阵 稀疏矩阵：大多数元素是0，记录非0元素的行号和列号， chapter8 栈 栈：一种特殊的线性表，其插入和删除操作都在表的同一端进行。这一端称为栈顶，另一端称为栈底。后进先出 数组描述 123456789101112131415161718192021222324252627282930313233343536373839404142template &lt;class T&gt;void arrayStack : public stack&lt;T&gt;&#123; public: arrayStack(int initialCapacity = 10); ~arrayStack() &#123;delete [] stack;&#125; bool empty() const &#123;return stackTop == -1;&#125; int size() const &#123;return stackTop+1;&#125; T&amp; top()&#123; if(stackTop == -1) throw stackEmpty(); return stack[stackTop]; &#125; void pop()&#123; if(stackTop == -1) throw stackEmpty(); stack[stackTop--].~T(); &#125; void push(const T&amp; theElement); private: int stackTop; int arrayLength; T *stack;&#125;;template&lt;class T&gt;arrayStack&lt;T&gt;::arrayStack(int initialCapacity)&#123; if(initialCapacity &lt; 1) .. arrayLength = initialCapacity; stack = new T[arrayLength]; stackTop = -1;&#125;template&lt;class T&gt;void arrayStack&lt;T&gt;::push(const T&amp; theElement)&#123; if(stackTop == arrayLength-1)&#123; changeLength1D(stack, arrayLength, 2*arrayLength); arrayLength *= 2; &#125; stack[++stackTop] = theElement;&#125; 链表描述 12345678910111213141516171819202122232425262728293031323334353637383940template&lt;class T&gt;class linkedStack : public stack&lt;T&gt;&#123; public: linkedStack(int initialCapacity = 10) &#123;stackTop = NULL; stackSize = 0;&#125; ~linkedStack(); bool empty() const &#123;return stackSize == 0;&#125; T&amp; top() &#123; if(stackSize == 0) throw .. return stackTop-&gt;element; &#125; void pop(); void push(const T&amp; theElement)&#123; stackTop = new chainNode&lt;T&gt;(theElement, stackTop); stackSize++; &#125; private: chainNode&lt;T&gt;* stackTop; int stackSize;&#125;template&lt;class T&gt;linkedStack&lt;T&gt;::~linkedStack()&#123; while(stackTop != NULL)&#123; chainNode&lt;T&gt;* nextNode = stackTop-&gt;next; delete stackTop; stackTop = nextNode; &#125;&#125;template&lt;class T&gt;void linkedStack&lt;T&gt;::pop()&#123; if(stackSize == 0) .. chainNode&lt;T&gt;* nextNode = stackTop-&gt;next; delete stackTop; stackTop = nextNode; stackSize--;&#125; 括号匹配：对一个字符串的左右括号进行匹配。 1234567891011121314151617181920void printMatchedPairs(string expr)&#123; //括号匹配 arrayStack&lt;int&gt; s; int length = (int)expr.size(); //扫描找左右括号 for(int i=0; i&lt;length; i++)&#123; if(expr.at(i) == '(')&#123; s.push(i); &#125;else&#123; if(expr.at(i) == ')')&#123; cout&lt;&lt;s.top(); s.pop(); &#125; &#125; &#125; while(!s.empty())&#123; cout&lt;&lt;"no match"&lt;&lt;endl; &#125;&#125; chapter9 队列 队列：一个线性表，其插入和删除操作在表的不同端进行。插入元素的一端为队尾，删除元素的一端为队首。 数组描述：环形数组：location(i) = (location(队列首元素)+i)%arrayLength； 12345678template&lt;class T&gt;void arrayQueue&lt;T&gt;::push(const T&amp; theElement)&#123; if((theBack+1)%arrayLength == theFront)&#123; //加倍长度 &#125; queueBack = (queueBack+1)%arrayLength; queue[queueBack] = theElement;&#125; 加倍长度 123456789101112131415T* newQueue = new T[2*arrayLength];//复制int start = (theFront+1)%arrayLength;if(start&lt;2)&#123; copy(queue+start, queue+start+arrayLength-1, newQueue);&#125;else&#123; //队列形成环 copy(queue+start, queue+arrayLength, newQueue); copy(queue, queue+theBack+1, newQueue+arrayLength-start);&#125;theFront = 2*arrayLength-1;theBack = arrayLength-2;arrayLength *= 2;delete[] queue;queue = newQueue; 12345678void pop()&#123; //删除队首 if(theFront == theBack)&#123; .. &#125; theFront = (theFront+1)%arrayLength; queue[theFront].~T();&#125; 列车车厢重排 chapter10 跳表和散列 字典：形如(k,v)的数对所组成的集合，其中k是关键字，v是与关键字对应的值。任意两个数对，其关键字都不等。 线性表描述： 12345678910111213template&lt;class K, class E&gt;pair&lt;const K, E&gt;* sortedChain&lt;K,E&gt;::find(const K&amp; theKey) const&#123; pairNode&lt;K,E&gt;* currentNode = firstNode; while(currentNode != NULL &amp;&amp; currentNode-&gt;element.first != theKey)&#123; currentNode = currentNode-&gt;next; &#125; if(currentNode != NULL &amp;&amp; currentNode-&gt;element.first == theKey)&#123; return &amp;currentNode-&gt;element; &#125; return NULL;&#125; 12345678910111213141516171819202122template&lt;class K, class E&gt;void sortedChain&lt;K,E&gt;::insert(const pair&lt;const K,E&gt;&amp; thePair)&#123; pairNode&lt;K,E&gt; *p = firstNode, *tp = NULL; while(p != NULL &amp;&amp; p-&gt;element.first &lt; thePair.first)&#123; tp = p; p = p-&gt;next; &#125; if(p != NULL &amp;&amp; p-&gt;element.first == thePair.first)&#123; //替换旧值 p-&gt;element.second = thePair.seconde; return; &#125; //无配对 pairNode&lt;K,E&gt; *newNode = new pairNode&lt;K,E&gt;(thePair, p); if(tp == NULL)&#123; firstNode = newNode; &#125;else&#123; tp-&gt;next = newNode; &#125; dSize++; return;&#125; 123456789101112131415template&lt;class K, class E&gt;void sortedChain&lt;K,E&gt;::erase(const k&amp; theKey)&#123; pairNode&lt;K,E&gt; *p = firstNode, *tp = NULL; while(p != NULL &amp;&amp; p-&gt;element.first &lt; theKey)&#123; tp = p; p = p-&gt;next; &#125; if(p != NULL &amp;&amp; p-&gt;element.first == theKey)&#123; if(tp == NULL) firstNode = p-&gt;next;//要删除p所以first往后 else tp-&gt;next = p-&gt;next; delete p; dSize--; &#125;&#125; 跳表：在链表的中部节点加一个指针，可减少比较次数。查找一个数对，首先和中间比较，查找关键字小则在左部分找。 1234567891011121314151617template&lt;class K, class E&gt;pair&lt;const K,E&gt;* skipList&lt;K,E&gt;::find(const K&amp; theKey) const&#123; if(theKey &gt;= tailKey) return null; skipNode&lt;K,E&gt;* beforeNode = headNode;//theKey之前，最右边 for(int i=levels; i&gt;=0; i--)&#123; //从上级到下级 while(beforeNode-&gt;next[i]-&gt;element.first &lt; theKey)&#123; beforeNode = beforeNode-&gt;next[i]; &#125; &#125; if(beforeNode-&gt;next[0]-&gt;element.first == theKey)&#123; return &amp;beforeNode-&gt;next[0]-&gt;element; &#125; return NULL;&#125; 1234567891011template&lt;class K, class E&gt;skipNode&lt;K,E&gt;* skipList&lt;K,E&gt;::search(const K&amp; theKey) const&#123; skipNode&lt;K,E&gt;* beforeNode = headerNode; for(int i=levels; i&gt;=0; i--)&#123; while(beforeNode-&gt;next[i]-&gt;element.first &lt; theKey)&#123; beforeNode = beforeNoe-&gt;next[i]; &#125; last[i] = beforeNode; &#125; return beforeNode-&gt;next[0];&#125; 123456789101112131415161718192021222324template&lt;class K, class E&gt;void skipList&lt;K,E&gt;::insert(const pair&lt;const K, E&gt;&amp; thePair)&#123; if(thePair.first &gt;= tailKey)&#123; ... &#125; skipNode&lt;K,E&gt;* theNode = search(thePair.first); if(theNode-&gt;element.first == thePair.first)&#123; theNode-&gt;element.second == thePair.second; return; &#125; int theLevel = level(); if(theLevel &gt; levels)&#123; theLevel = ++levels; last[theLevel] = headerNode; &#125; skipNode&lt;K,E&gt;* newNode = new skipNode&lt;K,E&gt;(thePair, theLevel+1); for(int i=0; i&lt;=theLevel; i++)&#123; //插入i级链表 newNode-&gt;next[i] = last[i]-&gt;next[i]; last[i]-&gt;next[i] = newNode; &#125; dSize++; return;&#125; 1234567891011121314151617template&lt;class K, class E&gt;void skipList&lt;k,E&gt;::erase(const K&amp; theKey)&#123; if(theKey &gt;= tailKey)&#123; ... &#125; skipNode&lt;K,E&gt;* theNode = search(theKey); if(theNode-&gt;element.first != theKey) return; for(int i=0; i&lt;=levels &amp;&amp; last[i]-&gt;next[i]==theNode; i++)&#123; last[i]-&gt;next[i] = theNode-&gt;next[i]; &#125; while(levels&gt;0 &amp;&amp; headerNode-&gt;next[levels]==tailNode)&#123; levels--; delete theNode; dSize--; &#125;&#125; 散列：用一个散列函数把字典的数对映射到一个散列表。 桶：散列表的每个位置叫一个桶，对关键字为k 的桶，f(k)是起始桶，桶的数量等于散列表的长度或大小。 除法散列函数：f(k) = k%D。理想的D，既是素数又不能被小于20的数整除。 冲突：当两个不同的关键字所对应的起始桶相同 溢出：如果存储桶没有空间存储一个数列 均匀散列函数 线性探查：找到下一个可用的桶。。 搜索方法：首先搜索起始桶f(k)，然后把散列表当做环表继续继续搜索下一个桶，直到以下情况之一发生为止：（1）存有关键字k的桶已找到；（2）到达一个空桶；（3）又回到起始桶f(k)。后两种说明关键字为k的数对不存在。 删除方法：①删除关键字后，需要一移动若干个数对。从删除位置的下一个桶开始，逐个检查每个桶，以确定要移动的元素，直至到达一个空桶或回到删除位置为止。在做删除移动时，不要把一个数对移到它的起始桶之前，否则查找会失败。②为每个桶增加一个域neverUsed。在散列表初始化时，这个域被置为true，当一个数对存入一个桶中时，置为false。搜索的结束条件： （2）变成neverUsed为tue。 链式散列：如果散列表的每一个桶可以容纳无限多的记录，则不存在溢出问题。给每个散列表的位置配置一个线性表。 chapter11 二叉树和其他树 一棵树t是一个非空的有限元素集合，其中一个元素为根，其余的元素组成t的子树。 级：level，树根是1级，其孩子是2级，.. 一棵树的高度或深度：树中级的个数 一个元素的度：其孩子的个数 一棵树的度：其元素的度的最大值 二叉树：binary tree，t是有限个元素的集合（可以为空）。当二叉树非空时，其中有一个元素称为根，余下的元素被划分为两棵二叉树，分别称为t的左子树和右子树。 二叉树和树的根本区别：（1）二叉树的每个元素都恰好有两棵子树。树的每个元素可以有任意数量的子树。（2）二叉树中每个元素的子树都是有序的，有左子树和右子树之分。树的子树是无序的。（二叉树可以为空，但是树不能为空） 算术表达式树没有括号。 二叉树的特性：（1）一棵二叉树有n个元素，n&gt;0，它有n-1条边。（2）一棵二叉树的高度为h，h&gt;=0，它最少有h个元素，最多有2^h-1个元素。（3）一棵二叉树有n个元素，n&gt;0，它的高度最大为n，最小高度为log2(n+1)。当高度为2^h-1个元素时，称为满二叉树。 对高度为h的满二叉树的元素，从第一层到最后一层，在每一次中从左至右，顺序编号，删除k个其编号为2^h-i元素，1&lt;=i&lt;=k&lt;2^h，得到完全二叉树。 设完全二叉树的一元素其编号为i，（1）i=1，为根，i&gt;1，父节点为i/2取整。（2）2i&gt;n，元素无左孩子，否则左孩子为2i。（3）2i+1&gt;n，无右孩子，否则右孩子为2i+1。 数组描述：把二叉树看成是缺少了部分元素的完全二叉树。 链表描述：节点两个指针域，leftChild，rightChild，一个element。 二叉树遍历：（1）前序遍历，根左右。（2）中序遍历，左根右。（3）后序遍历，左右根。（4）层次遍历。复杂性均为O(n)。 1234567891011121314151617181920212223void preOrder(binaryTreeNode&lt;T&gt; *t)&#123; if(t != NULL)&#123; visit(t); preOrder(t-&gt;leftChild); preOrder(t-&gt;rigthChild); &#125;&#125;void inOrder(binaryTreeNode&lt;T&gt;* t)&#123; if(t != NULL)&#123; preOrder(t-&gt;leftChild); visit(t); preOrder(t-&gt;rigthChild); &#125;&#125;void postOrder(binaryTreeNode&lt;T&gt;* t)&#123; if(t != NULL)&#123; preOrder(t-&gt;leftChild); preOrder(t-&gt;rigthChild); visit(t); &#125;&#125; 在层次遍历中，从顶层到底层，在同一层中，从左到右，依次访问树的元素，需要队列。 123456789101112131415void levelOrder(binaryTreeNode&lt;T&gt;* t)&#123; arrayQueue&lt;binaryTreeNode&lt;T&gt;*&gt; q; while(t != NULL)&#123; visit(t); if(t-&gt;leftChild != NULL)&#123; q.push(t-&gt;leftChild); &#125; if(t-&gt;rigthChild != NULL)&#123; q.push(t-&gt;rightChild); &#125; try&#123;t = q.front();&#125; catch&#123;..&#125; q.pop(); &#125;&#125; 12345678910111213//确定树的高度int height() const &#123;return height(root);&#125;int linkedBinaryTree&lt;E&gt;::height(BinaryTreeNode&lt;T&gt;* t)&#123; if(t == NULL) return 0; int hl = height(t-&gt;leftChild); int hr = height(t-&gt;rightChild); if(hl &gt; hr) return ++hl; else return ++hr;&#125; 当树t有节点超过两个孩子时，依然用二叉树表示。对每个节点x，可用其孩子节点的rightChild指针把x的所有孩子连成一条链表。x节点的leftChild指针指向该链表的第一个节点。 并查集：把每一个集合表示为一棵树，在查找时，我们把根元素作为集合标志符。为了确定元素theElement属于哪一个集合，从theElement节点开始，沿着节点到其父节点向上移动，直到根节点为止。 chapter12 优先级队列 优先级队列：是0个或多个元素的集合，每个元素都有一个优先级或值，操作top() push() pop()。最小/大优先级队列。相同优先级，任意顺序处理。 堆：一棵大根树，每个节点的值都大于或等于其子节点的值。一个大根堆，既是大根树也是完全二叉树。 插入：把新元素插入新节点，然后沿着从新节点到根节点的路径，执行一趟起泡操作，将新元素与其父节点的元素比较交换，直到后者大于或等于前者为止。 删除：删除根节点元素，把最后位置的删除，从根节点开始调整-&gt;最大堆/小。 O(height) = O(logn) 初始化：在空堆中执行n次插入操作。O(nlogn) 为了将完全二叉树转换成最大堆，从最后一个具有孩子的节点开始检查。 1234567891011121314void maxHeap&lt;T&gt;::push(const T&amp; theElement)&#123; if(heapSize == arrayLength-1)&#123; //数组长度加倍 &#125; //寻找插入位置 //从新叶子向上移动 int currentNode = ++heapSize; while(currentNode!=1 &amp;&amp; heap[currentNode/2]&lt;theElement)&#123; //父节点小于.. heap[currentNode] = heap[currentNode/2]; currentNode /= 2;//父节点移下来 &#125; heap[currentNode] = theElement;&#125; 123456789101112131415161718192021void maxHeap&lt;T&gt;::pop()&#123; if(heapSize == 0) throw queueEmpty(); heap[1].~T(); T lastElement = heap[heapSize--]; int currentNode = 1, child = 2; while(child &lt;= heapSize)&#123; if(child&lt;heapSize &amp;&amp; heap[child]&lt;heap[child+1])&#123; child++; &#125; if(lastElement &gt;= heap[child])&#123; break;//可以放在这个位置 &#125; //不可以 heap[currentNode] = heap[child]; currentNode = child; child *= 2; &#125; heap[currentNode] = lastElement;&#125; 123456789101112131415161718192021222324void maxHeap&lt;T&gt;::initialize(T *theHeap, int theSize)&#123; //初始化 delete [] heap; heap = theHeap; heapSize = theSize; for(int root=heapSize/2; root&gt;=1; root--)&#123; T rootElement = heap[root]; int child = 2*root; while(child &lt;= heapSize)&#123; if(child&lt;heapSize &amp;&amp; heap[child]&lt;heap[child+1])&#123; child++; &#125; if(rootElement &gt;= heap[child])&#123; break; &#125; heap[child/2] = heap[child]; child *= 2; &#125; heap[child/2] = rootElement; &#125; &#125; 堆排序 霍夫曼编码：利用小根堆实现，小根堆的每个元素包括一棵二叉树和它的权。 12345678910111213141516171819202122232425linkedBinaryTree&lt;int&gt;* huffmanTree(T weight[],int n)&#123; huffmanNode&lt;T&gt; *hNode = new huffmanNode&lt;T&gt;[n+1]; linkedBinaryTree&lt;int&gt; emptyTree; for(int i=1; i&lt;=n; i++)&#123; hNode[i].weight = weight[i]; hNode[i].tree = new linkedBinaryTree&lt;int&gt;; hNode[i].tree-&gt;makeTree(i, emptyTree, emptyTree); &#125; minHeap&lt;huffmanNode&lt;T&gt; &gt; heap(1); heap.initialize(hNode, n); huffmanNode&lt;T&gt; w, x, y;//从小根堆中提取两个树合并，直到剩下一棵树 linkedBinaryTree&lt;int&gt;*z; fo(int i=1; i&lt;n; i++)&#123; x = heap.top(); heap.pop(); y = heap.top(); heap.pop(); z = new linkedBinaryTree&lt;int&gt;; z-&gt;makeTree(0, *x.tree, *y.tree); w.weight = x.weight+y.weight; w.tree = z; heap.push(2); delete x.tree; delete y.tree; &#125; return heap.top().tree;&#125; chapter14 搜索树 二叉搜索树：一棵二叉树，可能为空；一棵非空二叉搜索树满足：（1）每个元素有一个关键字，并且任意两个元素的关键字都不同。所有关键字都是唯一的。（2）在根节点的左子树中，元素的关键字都小于根节点的关键字。（3）在根节点的右子树中，元素的关键字都大于根节点的关键字。（4）根节点的左、右子树也都是二叉搜索树。 索引二叉搜索树：在每个节点中添加一个leftSize域，这个域的值是该节点左子树的元素个数。 二叉搜索树的元素数量和形状随着操作而改变，所以用链表。 搜索：查找关键字为theKey的元素，先从根开始查找，如果根为空，那么搜索树不包含；如果不空，将theKey与根的关键字比较。如果theKey小，则在左子树中查找；大则在右子树中找；等于则查找成功。O(h)。 123456789101112131415pair&lt;const K,E&gt;* binarySearchTree&lt;K,E&gt;::find(const K&amp; theKey) const&#123; binaryTreeNode&lt;pair&lt;const K,E&gt;&gt; *p = root; while(p != NULL)&#123; if(theKey &lt; p-&gt;element.first)&#123; p = p-&gt;leftChild; &#125;else&#123; if(theKey &gt; p-&gt;element.first)&#123; p = p-&gt;rightChild; &#125;else&#123; return &amp;p-&gt;element; &#125; &#125; &#125; return NULL;&#125; 插入：插入新元素thePair，首先通过查找确定是否存在关键字与要插入的相同。搜索成功就替换；不成功就将新元素作为搜索中断节点的孩子插入。 12345678910111213141516171819202122232425262728void binarySearchTree&lt;K,E&gt;::insert(const pair&lt;const K,E&gt;&amp; thePair)&#123; binaryTreeNode&lt;pair&lt;const K,E&gt;&gt; *p = root, *pp = NULL; while(p != NULL)&#123; pp = p; if(thePair.first &lt; p-&gt;element.first)&#123; p = p-&gt;leftChild; &#125;else&#123; if(thePair.first &gt; p-&gt;element.first)&#123; p = p-&gt;rightChild; &#125;else&#123; p-&gt;element.second = thePair.second; return; &#125; &#125; &#125; binaryTreeNode&lt;pair&lt;const K,E&gt;&gt; *newNode = new binaryTreeNode&lt;pair&lt;const K,E&gt;&gt;(thePair); if(root != NULL)&#123; if(thePair.first &lt; pp-&gt;element.first)&#123; pp-&gt;leftChild = newNode; &#125;else&#123; pp-&gt;rightChild = newNode; &#125; &#125;else&#123; root = newNode; &#125; treeSize++;&#125; 删除：删除p（1）p是树叶，释放空间，若是根节点则为NULL。（2）p只有一棵非空子树，p是根节点，则p的唯一子树的根节点成为根节点，如果p有父节点pp，则修改pp的指针域，使其指向p的唯一孩子，释放节点p。（3）p有两棵非空子树，先将该节点替换为其左子树的最大元素或者右子树的最小元素，然后把替换元素的节点删除。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354void binarySearchTree&lt;K,E&gt;::erase(const K&amp; theKey)&#123; binaryTreeNode&lt;pair&lt;const K,E&gt;&gt; *p = root, *pp = NULL; while(p != NULL &amp;&amp; p-&gt;elemnt.first != theKey)&#123; pp = p; if(theKey &lt; p-&gt;element.first)&#123; p = p-&gt;leftChild; &#125;else&#123; p = p-&gt;rightChild; &#125; if(p == NULL)&#123; return; &#125; &#125; if(p == NULL)&#123; return; &#125; if(p-&gt;leftChild != NULL &amp;&amp; p-rightChild !=NULL)&#123; //转变成另外两种情况 binaryTreeNode&lt;pair&lt;const K,E&gt;&gt; *s = p-&gt;leftChild, *ps = p; while(s-&gt;rightChild != NULL)&#123; ps = s; s = s-&gt;rightChild;//max &#125; binaryTreeNode&lt;pair&lt;const K,E&gt;&gt; *q = new binaryTreeNode&lt;pair&lt;const K,E&gt;&gt;(s-&gt;element, p-&gt;leftChild, p-&gt;rightChild); if(pp == NULL)&#123; root = q; &#125;else if(p == pp-&gt;leftChild)&#123; pp-&gt;leftChild = q; &#125;else&#123; pp-&gt;rightChild = q; &#125; if(ps == p) pp = q;//无孩子 else pp = ps;//1个 delete p; p = s; &#125; binaryTreeNode&lt;pari&lt;const K,E&gt;&gt; *c; if(p-&gt;leftChild != NULL) c = p-&gt;leftChild; else c = p-&gt;rightChild; if(p == root) root = c; else&#123; if(p == pp-&gt;leftChild) pp-&gt;leftChild = c; else p-&gt;rightChild = c; &#125; treeSize--; delete p;&#125; 二叉搜索树的高度：O(logn) 索引二叉搜索树：一个节点的数值域：leftSize、key、value。 chapter15 平衡搜索树 AVL树：最坏情况下的高度为O(logn)的树称为平衡树。一棵空的二叉树是AVL树；如果T是一棵非空二叉树，TL和TR分别是其左子树和右子树，那么T满足以下条件时，T是一棵AVL树：1）TL和TR是AVL树；2）|hL-hR|&lt;=1。 一棵AVL搜索树既是二叉搜索树，又是AVL树。 AVL树特征：（1）一棵n个元素的AVL树，其高度是O(logn)。（2）对于每一个n，n&gt;=0，都存在一棵AVL树；（3）对一棵n元素的AVL搜索树，在O(logn)时间内可实现查找；（4）将一个新元素插入一棵n元素的AVL搜索树总，可以得到一棵n+1个元素的AVL树，而且插入用时为O(logn)；（5）一个元素从一棵n元素的AVL搜索树中删除，可以得到一棵n-1个元素的AVL树，而且用时为O(logn)。 AVL树一般用链表描述，为每个节点增加一个平衡因子bf，节点x的平衡因子bf(x)定义为：x的左子树高度-x的右子树高度。可能取值：-1,0,1。 AVL搜索树的插入：插入导致不平衡的几种情况：（1）不平衡树中，平衡因子的值限于：-2,-1,0,1,2。（2）平衡因子为2的节点在插入前的平衡因子为1.（3）只有从根到新插入节点的路径上的节点的平衡因子在插入后会改变。（4）假设A是离新插入节点最近的祖先，且平衡因子是-2或2，在插入前，从A到新插入节点的路径上，所有节点的平衡因子都是0。 一棵树从平衡变为不平衡的唯一过程：在插入操作之后，平衡因子bf(X)的值由-1变为-2，或者由1变为2。后一种情况只有在X的左子树XL中进行插入时才会出行。 B树： m叉索引树：可以是一棵空树，如果非空，必须满足以下特征：（1）在相应的扩充搜索树中，每个内部节点最多可以有m个孩子以及1~m-1个元素。（2）每一个含有p个元素的节点都有p+1个孩子。（3）对任意一个含有p个元素的节点，设k1,k2…,kp分别为关键字，k1&lt;k2&lt;..&lt;kp，设c0,c1,..,cp是该节点的p+1个孩子。在以c0为根的子树中，元素的关键字小于k1；在以cp为根的子树中，元素的关键字大于kp；… m叉搜索树的搜索：先从根节点开始，位于…，按照指针往下找。搜索中间子树的根，…找到或到达外部节点没找到。 m叉搜索树的插入：先查找，在x节点处查找失败，根据节点可容纳元素的个数插入位置。还可以加则根据大小插入，已经满了则生成一个新节点容纳。 m叉搜索树的删除：首先查找，（1）子节点都空，可以直接删除；（2）子节点至少有一个为空，用相邻非空子树的最大元素替换；（3）在根节点中删除，可能有多次替换。 m叉搜索树的高：logm(n+1)~n m阶B-树：是一棵m叉搜索树，如果B-树非空，那么特征：（1）根节点至少有2个孩子；（2）除根节点外，所有内部节点至少有&gt;=m/2个孩子；（3）所有外部节点在同一层，不算在高度里。 B-树的高度：设T是一棵高度为h的m阶B-树。令d=「m/2，则（1）2d^(h-1)&lt;=n&lt;=m^h-1；（2）logm(n+1)&lt;=h&lt;=logd((n+1)/2)+1 B-树的搜索：与m叉搜索树的算法类似。 B-树的插入：首先查找，如果不存在则将元素插入在搜索路径中所遇到的最后一个内部节点中。不允许有重复的关键字。 B树的删除：（1）该元素位于叶节点，（2）该元素位于非叶节点，（2）可转变成（1），过程是用一个元素来替换被删除元素，可以是左相邻子树最大的或者是右相邻子树最小的，替换元素必须在叶节点。只讨论情况（1）。①如果要删除的元素所在的叶节点其元素个数大于最少数，则直接删除 chapter16 图 图：有限集V和E的有序对，其中V的元素称为顶点，E的元素称为边。每一条边连接两个不同的顶点，而且用元组(i,j)表示，i,j为顶点。 有向边：带方向；无向边：不带方向。 当且仅当(i,j)是图的边，称顶点i和j是邻接的。边(i,j)关联于顶点i,j。 有向边(i,j)是关联至顶点j，关联于顶点i。顶点i邻接至顶点j，顶点j邻接于顶点i。 一个图是不能有重复的边，在无向图的任意两个顶点之间，最多只能有一条边。在有向图的任意两个顶点i,j之间，i到j至多一条边，j到i至多一条边。一个图不可能包含自连边/环。 权：每条边赋予一个表示成本的值。 G=(V,E)，G是连通的，当且仅当G的每一对顶点之间都有一条路径。如果H的顶点和边的集合分别是G的顶点和边的集合的子集，那么称H是G的子图。 一条始点和终点相同的简单路径称为环路。 没有环路的连通无向图是一棵树。 一个G的子图，如果包含G的所有顶点，且是一棵树，则称为G的生成树。 一个具有n个顶点的连通无向图至少有n-1条边。 在一个无向图中，有一个顶点i相关联的边数称为该顶点的度di。 特性：（1）∑d = 2e；（2）0&lt;=e&lt;=n(n-1)/2 一个具有n个顶点和n(n-1)/2条边的无向图是一个完全图。 设G是一个有向图，顶点i的入度指关联至该顶点的边数。顶点i的出度是指关联于该顶点的边数。 特性：（1）0&lt;=e&lt;=n(n-1)；（2）∑din = ∑dout = e 无权图的描述：邻接矩阵，邻接链表，邻接数组。 图的遍历： BFS，广度优先搜索， 123456789101112131415161718virtual void bfs(int v, int reach[], int label)&#123; arrayQueue&lt;int&gt; q(10); reach[v] = label; q.push(v); while(!q.empty())&#123; int w = q.front(); q.pop(); vertexIterator&lt;T&gt; *iw = iterator(w); int u; while((u=iw-&gt;next()) != 0)&#123; if(reach[u] == 0)&#123; q.push(u); reach[u] = label; &#125; &#125; delete iw; &#125;&#125; DFS，深度优先搜索 12345678910111213141516void dfs(int v, int reach[], int label)&#123; graph&lt;T&gt;::reach = reach; graph&lt;T&gt;::label = label; rDfs(v);&#125;void rDfs(int v)&#123; reach[v] = label; vertexIterator&lt;T&gt; *iv = iterator(v); int u; while((u=iv-&gt;next()) != 0)&#123; if(reach[u] == 0)&#123; rDfs(u); &#125; &#125; delete iv;&#125; chapter17 贪婪算法 贪婪算法：greedy method，逐步构造一个最优解。每一步，在一定的标准下，作出一个最优决策。在每一步作出的决策，在以后的步骤中都不可更改。做出决策所依据的标准称为贪婪准则。 拓扑排序：任务有先后顺序，有向图表示，顶点活动网络（AOV，activity on vertex）。 1234567891011121314151617181920212223242526272829303132333435bool topologicalOrder(int *theOrder)&#123; int n = numberOfVertices(); //计算入度 int *inDegree = new int[n+1]; fill(inDegree+1, inDegree+n+1, 0); for(int i=1; i&lt;=n; i++)&#123; vertexIterator&lt;T&gt; *ii = iterator(i); int u; while((u=ii-&gt;next()) != 0)&#123; inDegree[u]++; &#125; &#125; //入度=0的顶点入栈 arrayStack&lt;int&gt; stack; for(int i=1; i&lt;=n; i++)&#123; if(inDegree[i] == 0)&#123; stack.push(i); &#125; &#125; int j = 0; while(!stack.empty())&#123; int nextVertex = stack.top(); stack.pop(); theOrder[j++] = nextVertex; vertexIterator&lt;T&gt; *iNextVertex = iterator(nextVertex); int u; while((u=iNextVertex-&gt;next()) != 0)&#123; inDegree[u]--; if(inDegree[u] == 0)&#123; stack.push(u); &#125; &#125; &#125; return (j == n);&#125; 单源最短路径： predecessor[i]是从源顶点到达顶点i的路径中顶点i前面的那个顶点。 1234567891011121314151617181920212223242526272829303132333435363738394041void shortestPath(int sourceVertex, T* distanceFromSource, int* predecessor)&#123; //distanceFromSource中返回最短路径 graphChain&lt;int&gt; newReachableVertices; //初始化 for(int i=1; i&lt;=n; i++)&#123; distanceFromSource[i] = a[sourceVertex][i]; if(distanceFromSource[i] == noEdge)&#123; predecessor[i] = -1; &#125;else&#123; predecessor[i] = sourceVertex; newReachableVertices.insert(0, i); &#125; &#125; distanceFromSource[sourceVertex] = 0; predecessor[sourceVertex] = 0; while(!newReachableVertices.empty())&#123; chain&lt;int&gt;::iterator iNewReachableVertices = newReachableVertices.begin(); chain&lt;int&gt;::iterator theEnd = newReachableVertices.end(); int v = *iNewReachableVertiecs; iNewReachableVertices++; while(iNewReachableVertices != theEnd)&#123; int w = *iNewReachableVertices; iNewReachableVertices++; if(distanceFromSource[w] &lt; distanceFromSource[v])&#123; v = w; &#125; &#125; newReachableVertices.eraseElement(v); for(int j=1; j&lt;=n; j++)&#123; if(a[v][j]!=noEdge &amp;&amp; (predecessor[j]==-1 || distanceFromSource[j]&gt;distanceFromSource[v]+a[v][j]))&#123; distanceFromSource[j] = distanceFromSource[v]+a[v][j]; if(predecessor[j] == -1)&#123; newReachableVertices.insert(0, j); &#125; predecessor[j] = v; &#125; &#125; &#125;&#125; 最小生成树 kruskal：分步骤选择n-1条边，每步选择一条边，贪婪准则：从剩下的边中，选择一条权最小且不会产生环路的边加入已经选择的边集。O(n+eloge) Prim：分布选边来创建最小生成树，而且一步选择一条边。贪婪准则：从剩余的边中，选择一条成本最小的边，并且把他们加入已选的边集中形成一棵树。快一点。O(n^2) Sollin：△ chapter18 分而治之 归并排序 快速排序 选择：从n元素数组a[0:n-1]中找出第k小的元素。首先对n个元素的数组a[0:n-1]排序，然后取出a[k-1]中的元素。 12345678910111213141516171819202122232425262728293031323334T select(T a[], int n, int k)&#123; int max = indexOfMax(a, n); swap(a[n-1], a[max]); return select(a, 0, n-1, k);&#125;T select(T a[], int leftEnd, int rightEnd, int k)&#123; if(leftEnd &gt;= rightEnd) return a[leftEnd]; int leftCursor = leftEnd, rightCursor = rightEnd+1; T pivot = a[leftEnd]; while(true)&#123; do&#123; leftCursor++; &#125;while(a[leftCursor] &lt; pivot); do&#123; rightCursor--; &#125;while(a[rightCursor] &gt; pivot); if(leftCursor &gt;= rightCursor) return; swap(a[leftCursor], a[rightCursor]); &#125; if(rightCursor-leftEnd+1 == k)&#123; return pivot; &#125; a[leftEnd] = a[rightCursor]; a[rightCursor] = pivot; if(rightCursor-leftEnd+1 &lt; k)&#123; return select(a, rightCursor+1, rightEnd, k-rightCursor+leftEnd-1); &#125;else&#123; return select(a, leftEnd, rightCursor-1, k); &#125;&#125; chapter19 动态规划 所有顶点对之间的最短路径： 可以Dijkstra算法n次求解。 Floy算法：假设图G有n个顶点，且从1到n编号，c(i,j,k)表示从顶点I到j的一条最短路径的长度，其中间顶点的编号不都大于k。如果(i,j)存在，则c(i,j,0)表示该边长度。c(i,j,n)是从i到j的最短路径长度。 kay表示i到j的最短路径中的最大的k值。 123456789101112131415161718192021222324void allPairs(T **c, int **kay)&#123; //initialize for(int i=1; i&lt;=n; i++)&#123; for(int j=1; j&lt;=n; j++)&#123; c[i][j] = a[i][j]; kay[i][j] = 0; &#125; &#125; for(int i=1; i&lt;=n; i++)&#123; c[i][i] = 0; &#125; for(int k=1; k&lt;=n; k++)&#123; for(int i=1; i&lt;=n; i++)&#123; for(int j=1; j&lt;=n; j++)&#123; if(c[i][k]!=noEdge &amp;&amp; c[k][j]!=noEdge &amp;&amp; (c[i][j]==noEdge || c[i][j]&gt;c[i][k]+c[k][j]))&#123; c[i][j] = c[i][k]+c[k][j]; kay[i][j] = k; &#125; &#125; &#125; &#125;&#125; 1234567891011121314template&lt;class T&gt;int indexOfMax(T a[], int n)&#123; //查找数组a[0:n-1]的最大元素 if(n &lt;= 0)&#123; throw illeaglaParameterValue(".."); &#125; int indexOfMax = 0; for(int i=1; i&lt;n; i++)&#123; if(a[indexOfMax] &lt; a[i])&#123; indexOfMax = i; &#125; &#125; return indexOfMax;&#125; 1、选择排序 首先找出最大的元素，把它调a[n-1]，然后在余下的n-1个元素中找出最大的元素，把它移到a[n-2]，如此直到剩下一个元素。 比较次数：n(n-1)/2，移动次数：3(n-1) 123456789template&lt;class T&gt;void selectionSort(T a[], int n)&#123; //选择排序a[0:n-1] for(int size=n; size&gt;1; size--)&#123; //先找出n个元素中最大的，再n-1中的,.. int j = indexOfMax(a, size);//size not n swap(a[j], a[size-1]); &#125;&#125; 及时终止的选择排序： 为了去除不必要的迭代，在查找最大元素时，同时检查数组是否已经有序。 1234567891011121314151617template&lt;class T&gt;void selectionSort(T a[], int n)&#123; //及时终止的选择排序 bool sorted = false; for(int size=n; !sorted&amp;&amp;(size&gt;1); size--)&#123; int indexOfMax = 0; sorted = true; //查找最大元素 for(int i=1; i&lt;size; i++)&#123; if(a[indexOfMax] &lt;= a[i]) indexOfMax = i;//index从0开始，大的在后面 else sorted = false; &#125; swap(a[indexOfMax], a[i]); &#125;&#125; 2、冒泡排序 在一次冒泡过程中，相邻的元素比较，如果左边的元素大于右边的元素，则交换。把最大的元素移到序列最右端。 12345678910111213141516template&lt;class T&gt;void bubble(T a[], int n)&#123; //一次冒泡，把a[0:n-1]中最大元素移到右边 for(int i=0; i&lt;n-1; i++)&#123;//n-1 if(a[i] &gt; a[i+1])&#123; swap(a[i], a[i+1])； &#125; &#125;&#125;template&lt;class T&gt;void bubbleSort(T a[], int n)&#123; for(int i=n; i&gt;1; i--)&#123; bubble(a[], i); &#125; &#125; 及时终止的冒泡排序： 如果在一次冒泡过程中没有发生元素互换，说明数组已经有序。 12345678910111213141516template&lt;class T&gt;bool bubble(T a[], int n)&#123; bool swapped = false; for(int i=0; i&lt;n-1; i++)&#123; if(a[i] &gt; a[i+1])&#123; swap(a[i], a[i+1]); swapped = true; &#125; &#125; return swapped;&#125;template&lt;class T&gt;void bubbleSort(T a[], int n)&#123; for(int i=n; i&gt;1&amp;&amp;bubble(a,i); i++);&#125; 3、名词排序 计算出名次，就可以移到与其名次对应的位置。 名次：所有比该元素小的元素的个数加上在它左边出现的与它相同的元素的个数。 123456789101112131415161718192021222324252627282930template&lt;class T&gt;void rank(T a[], int n, int r[])&#123; //计算名次 for(int i=0; i&lt;n; i++)&#123; r[i] = 0;//初始化 &#125; //比较所有元素对 for(int i=1; i&lt;n; i++)&#123; for(int j=0; j&lt;i; j++)&#123;//! if(a[j] &lt;= a[i]) r[i]++; else r[j]++;//! &#125; &#125;&#125;template&lt;class T&gt;void rearrange(T a[], int n, int r[])&#123; //使用附加数组将元素排序 T *u = new T [n];//附加数组 //把a中元素移到u中正确位置 for(int i=0; i&lt;n; i++)&#123; u[r[i]] = a[i]; &#125; //把u中元素移回a for(int i=0; i&lt;n; i++)&#123; a[i] = u[i]; &#125;&#125; 4、原地重排 已经用rank计算出名次，不借助其他空间，将a中的元素按照名次排序。 1234567891011template&lt;class T&gt;void rearrange(T a[], int n, int r[])&#123; //原地重排 for(int i=0; i&lt;n; i++)&#123; while(r[i] != i)&#123;//r[i]中是名次 int t = r[i]; swap(a[i], a[t]); swap(r[i], r[t]); &#125; &#125;&#125; 5、插入排序 从单元数组开始，不断实施插入操作。 12345678910111213141516template&lt;class T&gt;void insert(T a[], int n, const T&amp; x)&#123; //x插入有序数组 for(int i=n-1； i&gt;=0&amp;&amp;x&lt;a[i]; i--)&#123; a[i+1] = a[i];//大的往后挪 &#125; a[i+1] = x;&#125;template&lt;class T&gt;void insertionSort(T a[], int n)&#123; for(int i=1; i&lt;n; i++)&#123; T t = a[i]; insert(a, i, t); &#125; &#125; 6、箱子排序 首先把分数相同的节点放在同一个箱子里，然后把箱子链接起来就得到有序的链表。每一个箱子都是一个链表，一个箱子的节点数目介于0~n之间。开始时所有箱子都是空的，排序：（1）逐个删除输入链表的节点，把删除的节点分配到相应的箱子里；（2）把每一个箱子中的链表手机并链接起来，使其成为一个有序链表。 123456789101112131415161718192021void binSort(chain&lt;T&gt;&amp; theChain, int range)&#123; //初始化 chain&lt;T&gt; *bin; bin = new chain&lt;T&gt;[range+1]; //取出分配到箱子里 int numberOfElements = theChain.size(); for(int i=1; i&lt;=nu,berOfElements; i++)&#123; T x = theChain.get(0); theChain.erase(0); bin[x.score].insert(0,x); &#125; //从箱子中手机元素 for(int j=range; j&gt;=0; j--)&#123; while(!bin[j].empty())&#123; T x = bin[j].get(0); bin[j].erase(0); theChain.insert(0,x); &#125; &#125; delete [] bin;&#125; 7、基数排序 把数按照某种基数分解为数字，然后对数字排序。 （1）利用箱子排序，根据最低位数字，对10个数进行排序。 （2）利用箱子排序，对（1）的结果根据次低位排序。…. 8、堆排序 先用n个待排序的元素来初始化一个大根堆，然后从堆中逐个提取元素。按非递减排列。初始化O(n)，每次删除O(logn)，总的O(nlogn)。 12345678910void heapSort(T a[], int n)&#123; maxHeap&lt;T&gt; heap(1); heap.initialize(a, n); for(int i=n-1; i&gt;=1; i--)&#123; T x = heap.top(); heap.pop(); a[i+1] = x; &#125; heap.deactivateArray();&#125; 9、归并排序 若n为1，则算法终止；否则，将序列划分为k个子序列。先对每一个子序列排序，然后将有序子序列归并为一个序列。k=2称为merge sort 首先将每两个相邻的大小为1的子序列归并，然后将每两个相邻的大小为2的子序列归并，。。直到只剩下一个有序序列。轮流地将元素从a到b，从b到a。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748void mergeSort(T a[], int n)&#123; T *b = new T[n]; int segmentSize = 1; while(segmentSize &lt; n)&#123; mergePass(a, b, n, segmentSize); segmentSize += segmentSize; mergePass(b, a, n, segmentSize); segmentSize += segmentSize; &#125; delete[] b;&#125;//仅确定要归并的子序列的左右边界void mergePass(T x[], T y[], int n, int segmentSize)&#123; int i=0; while(i &lt;= n-2*segmentSize)&#123; merge(x, y, i,i+segmentSize-1, i+2*segmentSize-1); i = i+2*segmentSize; &#125; //少于两个满数据段 if(i+segmentSize &lt; n)&#123; merge(x, y, i, i+segmentSize-1, n-1); &#125;else&#123; //1个 for(int j=i; j&lt;n; j++)&#123; y[j] = x[j]; &#125; &#125;&#125;void merge(T c[], T d[], int startOfFirst, int endOfFirst, int endOfSecond)&#123; int first = startOfFirst; int second = endOfFirst+1; int result = startOfFirst; while((first&lt;=endOfFirst) &amp;&amp; (second&lt;=endOfSecond))&#123; if(c[first] &lt;= c[second]) d[result++] = c[first++]; else d[result++] = c[second++]; &#125; //归并剩余元素 if(first &gt; endOfFirst) for(int q=second; q&lt;=endOfSecond; q++) d[result++] = c[q]; else for(int q=first; q&lt;=endOfFirst; q++) d[result++] = c[q];&#125; 10、快速排序 把n个元素划分为三段：左段left，中间段middle，右段right。中段仅有一个元素，左段的元素都不大于中间段的元素，右段的元素都不小于中间段的元素，可对左右独立排序，且排序后不用归并。 12345678910111213141516171819202122232425262728293031323334void quichSort(T a[], int n)&#123; if(n &lt;= 1)&#123; return; &#125; int max = indexOfMax(a, n); swap(a[n-1], a[max]); quickSort(a, 0, n-2);&#125;void quickSor(T a[], int leftEnd, int rightEnd)&#123; if(leftEnd &gt;= rightEnd) return; int leftCursor = leftEnd; int rightCursor = rightEnd+1; T pivot = a[leftEnd]; while(true)&#123; do&#123; leftCursor++; &#125;while(a[leftCursor] &lt; pivot); do&#123; rightCursor--; &#125;while(a[rightCursor] &gt; pivot); if(leftCursor &gt;= rightCursor)&#123; break; &#125; swap(a[leftCursor], a[rightCursor]); &#125; a[leftEnd] = a[rightCursor]; a[rightCursor] = pivot; quickSort(a, leftEnd, rightCursor-1); quickSort(a, rightCursor+1， rightEnd);&#125;]]></content>
      <tags>
        <tag>study</tag>
        <tag>data structures</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Operatring System]]></title>
    <url>%2F2018%2F08%2F02%2FOperatring-System%2F</url>
    <content type="text"><![CDATA[最近正好复习一下操作系统，总结一下，以后看也方便一点。 Operating System（一段英文介绍，还没写好，先空着） 目录 chapter1 导论 chapter2 操作系统结构 chapter3 进程 chapter4 线程 chapter5 CPU调度 chapter6 进程同步 chapter7 死锁 chapter8 内存管理 chapter9 虚拟内存 chapter10 文件系统接口 chapter11 文件系统实现 chapter12 大容量存储器的结构 chapter13 I/O输入系统 chapter14 保护 chapter 1 导论 计算机系统大致分为4个部分：计算机硬件、操作系统、系统程序与应用程序、用户。（硬件为系统提供基本的计算资源，应用程序规定了用户按何种方式使用这些资源，操作系统控制和协调用户的应用程序对硬件的使用） 从用户视角：使用方便 -&gt; 性能 -&gt;资源利用率 ease of use/ performance/ resource utilization 从系统视角：a resource allocator 、a control program 定义：资源管理、程序控制、方便用户 计算机启动过程 中断：硬件可随时通过系统总线向CPU发出信号触发中断，软件通过执行特别操作（系统调用）触发中断。当CPU中断时，它暂停正在做的事转到中断服务程序开始位置的地址，中断服务程序开始执行，执行完后，CPU重新执行被中断的计算。 存储结构：寄存器 -&gt; 高速缓存 -&gt; 主存 -&gt; 电子磁盘 -&gt; 磁盘 -&gt; 光盘 -&gt; 磁带 I/O结构：查询，中断，DMA 单处理器系统：仅用一个处理器来完成系统操作和目标仿真 。 多处理器系统：增加吞吐量，规模经济，增加可靠性 。非对称多处理（asymmetric multiprocessing）：每个处理器都有各自特定的任务（主从）。对称多处理：每个处理器都要完成操作系统中的所有任务。 集群系统：将多个CPU集中起来完成计算任务。与多处理器系统不同，由两个或多个独立的系统耦合起来。非对称集群/对称集群 集群：多个计算机耦合成单一系统，耦合度较低，消息通信。 多道程序：由多个CPU组成的单一物理试题，共享存储间通信。 多道程序系统：提供了一个可以充分使用各种系统资源的环境。目的是无论何时都有进程在运行，从而使CPU利用率达到最大化。 分时操作系统：允许许多用户同时共享计算机。目的是在进程之间快速切换CPU以便用户在程序运行时能与其进行交互。 双重模式：用户模式，监督程序模式/系统模式/特权模式。提供了保护操作系统和用户程序不受错误用户程序影响的手段。将能引起损害的机器指令作为特权指令。 定时器（timer）：确保操作系统能维持对CPU的控制，也必须防止用户程序陷入死循环或不调用系统服务，并且不将控制权返回到操作系统。 进程管理：进程是系统工作的单元。系统由多个进程组成，操作系统进程/用户进程。 内存管理：内存通常是CPU所能直接寻址和访问的唯一大容量存储器。 存储管理：文件系统管理，大容量存储器管理，高速缓存，I/O系统。 保护和安全：保护是一种控制进程或用户对计算机系统资源的访问的机制。安全主要是防止系统不受外部或内部攻击。 分布式系统：将一组物理上分开来的、各种可能异构的计算机系统通过网络连接在一起，为用户提供系统所维护的各种资源的计算机的集合。 专用系统：实时嵌入系统，多媒体系统，手持系统 计算环境：传统计算，客户机-服务器计算，对等计算，基于Web的计算。 chapter2 操作系统结构 操作系统服务： 用户有用（1）用户界面：命令行界面，批界面。最常用的是图形用户界面。（2）程序执行：系统必须能将程序装入内存并运行程序。（3）I/O操作：为了提高效率和进行保护，用户通常不能直接进行控制I/O设备，因此OS必须提供进行I/O操作的方法。（4）文件系统操作。（5）通信：发生在同一台计算机运行的两个进程之间，运行在由网络连接起来的不同的计算机上的进程之间。实现：共享内存，消息交换。（6）错误检测：OS需要知道可能出现的错误。 系统高效运行（1）资源分配：多个用户/多个作业运行时。（2）统计：记录哪些用户使用了多少和什么资源。（3）保护和安全。 用户界面：（1）命令解释程序：shell，获取并执行用户指定的下一条指令。执行方法：命令解释程序本身包含代码以执行这些命令，由系统程序实现绝大多数命令。（2）图形用户界面：GUI，提供基于鼠标的窗口和菜单系统作为接口。 系统调用：system call，提供了OS提供的有效服务界面。一般使用API。传递参数的三种方法：（1）寄存器，简单。（2）寄存器传递参数块的首地址，参数通常存在内存的块和表中，并将块的地址通过寄存器来传递。（3）参数可通过程序放在或压入堆栈中，并通过OS弹出。 系统调用类型：（1）进程控制。（2）文件管理。（3）设备管理。（4）信息维护。（5）通信，消息传递模型（通信进程通过彼此之间交换消息来交换信息，直接或间接地通过一个共同的邮箱，在通信前必须先打开连接，必须知道另一个通信试题的名称）和共享内存模型（进程使用shared memory create和shared memory attach系统调用来获得其他进程所拥有的内存区域的访问权）。 系统程序：文件管理，状态信息，文件修改，程序语言支持，程序装入和执行，通信。 OS设计目标：首要问题是定义系统的目标和规格，用户目标和系统目标。 机制和策略：机制决定如何做（方法），策略决定做什么（目的）。 OS结构：简单结构，分层（自定向下，每层只能利用较低层的功能和服务），微内核（将所有非基本部分从内核中移走，使客户程序和运行在用户空间的各种服务之间进行通信，利于扩充OS），模块（比分层更灵活，任一模块能调用任何其他模块，不需要调用消息传递来通信）。 虚拟机：在并行运行几个不同的执行环境时能够共享相同的硬件。每个虚拟机完全独立于其他虚拟机，因此没有安全问题，但同时也没有直接资源共享。优点：可通过共享小型磁盘来共享文件，可通过定义一个虚拟机的网络来传递消息。 系统启动：之前1中有个链接。引导程序存储在固件总，OS保存在磁盘上。 并行：多个CPU多个程序；并发：一个CPU多个程序。 chapter3 进程 作业：用户在一次解题或一个事物处理过程中要求计算机系统所做工作的集合。它包括用户程序、所需要的数据及控制命令等。作业是由一系列有序的步骤组成的。 进程：一个程序在一个数据集合上的一次运行过程。 线程：线程是进程中的一个实体，是被系统独立调度和执行的基本单位。 管程：管程实际上是定义了一个数据结构和在该数据结构上的能为并发进程所执行的一组操作，这组操作能同步进程和改变管程中的数据。 进程间的通信：信号、信号量、消息队列、共享内存。 进程：包括程序代码/文本段、当前活动，堆栈段、数据段、堆..。程序本身不是进程。程序是被动实体，进程是活动实体。有一个程序计数器用来表示一个要执行的命令和相关资源集合。两个进程可与同一程序相关，但被当做两个独立的执行序列。 进程状态：（1）新的，进程正在被创建。（2）运行，指令正在被执行。（3）等待，进程等待某个时间的发生。（4）就绪，进程等待分配处理器。（5）终止，进程完成执行。一次只有一个进程可在一个处理器上运行，但是多个进程可处于就绪或等待状态。 进程控制块：PCB。进程状态，程序计数器（下个指令的地址），CPU寄存器，CPU调度信息，内存管理信息，记账信息，I/O状态信息。 调度程序：（1）长期调度程序/作业调度程序：从缓冲池中选择进程，并装入内存以准备执行。（2）短期调度程序/CPU调度程序：从准备执行的进程中选择进程，并并为之分配CPU。主要差别为执行的频率，（1）低。 中期调度程序：将进程从内存中移出，从而降低多道程序设计的程度。之后，进程能被重新调入内存，并从中断处继续执行。（交换） 上下文切换：将CPU切换到另一个进程需要保存当前进程的状态并恢复另一个进程的状态。PCB 进程创建：进程在其执行过程中，能通过创建进程系统调用创建多个新进程，创建进程称为父进程，而新进程称为子进程。进程标识符PID。 创建新进程时：①父进程与子进程并发执行 ②父进程等待，直到某个或全部子进程执行完。新进程的地址空间：①子进程是父进程的复制品 ②子进程装入另一个新程序。 fork()：子进程返回0，父进程返回子进程PID。exec()。wait()。进程终止：exit()。 进程间通信：（1）共享内存：建立起一块供协作进程共享的内存区域，进程通过向此共享区域读或写入数据来交换信息。速度快。（2）消息传递：通过协作进程间交换消息来实现通信。交换较少数量的数据。易于实现。（直接通信/间接通信，同步(阻塞)/异步(非阻塞)，0缓冲/有限缓冲/无线缓冲） 客户机-服务系统通信：（1）socket：通信的端点。（2）远程过程调用RPC。（3）Java的远程方法调用RMI。 chapter4 线程 线程：CPU使用的基本单元，由线程ID，程序计数器，寄存器集合和栈组成。共享代码段、数据段、其他资源，寄存器和栈不共享。 多线程编程优点：响应度高，资源共享，经济，多处理器体系结构的利用。 多线程模型：（1）多对一，许多用户级线程映射到一个内核线程，一个线程阻塞则整个阻塞，任一时刻只有一个线程能访问内核。（2）一对一，每个用户线程映射到一个内核线程，允许多个线程并行运行在多处理器系统上，一个用户线程就需要创建一个相应的内核线程从而限制了系统所支持的线程数量。（3）多对多，多路复用了许多用户线程到同样数量或更小数据量的内核线程上，可以创建任意多的用户线程，并且相应内核线程能在多处理器系统上并发执行，当一个线程阻塞内核能调度另一个线程来执行。 线程库：为程序员提供创建和管理线程的API。（1）在用户空间提供一个没有内核支持的库，本地函数调用。（2）执行一个由OS直接支持的内核级的库。 （1）fork()之后立即调用exec()，没必要复制所有线程。（2）fork()之后另一进程不调用exec()，另一进程应复制所有线程。 线程取消：在线程完成之前来终止线程的任务。（1）异步取消：一个线程立即终止目标线程。（2）目标线程不断地检查它是否应终止，这允许目标线程有机会以有序方式来终止自己。 信号：用来通知进程某个特定事件已经发生了。（1）信号是由特定事件的发生所产生的。（2）产生的信号要发送到进程。（3）一旦发送，信号必须加以处理。 线程池：在进程开始时创建一定数量的线程，并放入到池中以等待工作。当服务器收到请求时，它会唤醒池中的一个线程，并将要处理的请求传递给它。一旦线程完成了服务，它会返回到池中再等待工作。如果池中没有可用的线程，那么服务器会一直等待知道有空线程为止。优点：①通常用现有线程处理请求要比等待创建新的线程要快。②线程池限制了在任何时候可用线程的数量。 chapter5 CPU调度 进程执行由CPU执行和I/O等待周期组成。进程在这两个状态之间切换。 CPU调度程序：4种环境：①当一个进程从运行状态切换到等待状态。非抢占。②当一个进程从运行状态切换到就绪状态。③当一个进程从等待状态切换到就绪状态。④当一个进程终止时。非抢占。采用非抢占调度，一旦CPU分配给一个进程，那么该进程会一直使用CPU直到进程终止或切换到等待状态。 分派程序：一个模块，用来将CPU的控制交给由短期调度程序选择的进程。功能：切换上下文，切换到用户模式，跳转到用户程序合适位置以重新启动程序。 调度准则：CPU使用率（使CPU尽可能忙），吞吐量（测量工作量），周转时间（从进程提交到进程完成的时间段），等待时间（在就绪队列中等待所花费时间之和），响应时间（从提交请求到产生第一响应的时间）。需要使CPU使用率和吞吐量最大化，而使周转时间、等待时间和响应时间最小化。 调度算法：（1）先到先服务 FCFS，先请求CPU的进程先分配到CPU。FIFO队列。非抢占。（2）最短作业有限调度 SJF，当CPU空闲时，会赋给具有最短CPU区间的进程，同样长度FCFS。平均等待时间最小。用于长期调度。抢占/非抢占。抢占SJF/最短剩余时间优先调度。（3）优先级调度，每个进程都有一个优先级与其关联，具有最高优先级的进程会分配到CPU，具有相同优先级FCFS。抢占/非抢占。无穷阻塞/饥饿，老化（逐渐增加在系统中等待很长时间的进程的优先级）。（4）轮转法调度，专门为分时系统设计，类似FCFS，增加了抢占。时间片（一个较小时间单元），循环队列，FIFO，可抢占。（5）多级队列调度，将就绪队列分成多个独立队列，根据进程的属性，一个进程被永久地分配到一个队列，每个队列有自己的调度算法。队列之间通常采用固定优先级抢占调度/划分时间片。（6）多级反馈队列调度，根据不同CPU区间的特点以区分进程，如果进程使用过多CPU时间，那么它会被转移到更低优先级队列。将I/O约束和交互进程留在更高优先级队列，在较低优先级队列中等待时间过长的进程会被转移到更高优先级队列。（队列0中的1个时间片，未完成放到队列1尾部）。 线程调度：进程竞争范围 PCS，系统竞争范围 SCS。 算法评估：（1）分析评估法。使用给定算法和系统负荷，产生一个公式或数字，以评估对于该负荷算法的性能。（2）确定模型法。采用特殊预先确定的负荷，计算在给定负荷下每个算法的性能。 chapter6 进程同步 临界区问题：critical-section problem，设计一个以便进程协作的协议。进入区：entry section，实现进程请求允许进入临界区的代码。退出区：exit section。剩余区：remainder sction。 解答的三个要求：（1）互斥：mutual exclusion，如果进程Pi在其临界区内执行，那么其他进程都不能在其临界区内执行。（2）前进：progress，如果没有进程在其临界区内执行且有进程需进入临界区，那么只有那些不在剩余区内执行的进程可参加选择，以确定谁能下一个进入临界区，且这种选择不能无限推迟。（3）有限等待：bounded waiting，从一个进程作出进入临界区的请求，直到该请求允许为止，其他进程允许进入其临界区的次数有上限。 典型进程Pi的通用结构：do{进入区 临界区 退出区 剩余区}while(TRUE); 两种方法：（1）抢占内核：preemptive kernel。适合实时编程，响应快。（2）非抢占内湖：nonpreemptive kernel。 Peterson算法：一个经典的基于软件的临界区问题的解答。适用于两个进程在临界区与剩余区间交替执行。（Pi，Pj，j=1-i）共享两个数据项：int turn;表示哪个进程可以进入临界区。boolean flag[2];表示哪个进程想要进入临界区。 锁：通过要求临界区用锁来防护，就可以避免竞争条件。 单处理器：修改共享变量时禁止中断。 多处理器：原子。TestAndSet() &amp; Swap()。 信号量：semaphore，信号量S，整数变量，两个标准原子操作 wait() &amp; signal()。 123456do&#123; waiting(mutex); //critical section signal(mutex); //remainder section&#125;while(TRUE); 计数信号量：可用来控制访问具有若干个实例的某种资源。 二进制信号量：互斥锁，值为0或1。 忙等待，自旋锁：当一个进程位于其临界区内时，任何其他试图进入其临界区的进程都必须在其进入代码中连续地循环。（解决就是block() &amp; wakeup()，S&lt;0加入队列里阻塞，signal()唤醒） 死锁：deadlocked，两个或多个进程无限地等待一个时间，而该事件只能由这些等待进程之一来产生。 饥饿/无限期阻塞：starvation/indefinite blocing，进程在信号量内无限期等待。 有限缓冲问题：n个缓冲项；信号量mutex互斥，初始化为1；信号量empty，初始化为n；信号量full，初始化为0。 读者-写者问题：要求写者对共享数据库有排他的访问。 哲学家进餐问题：思考和吃饭，一边一只筷子。 管程：monitor，管程结构确保一次只有一个进程能在管程内活动。 原子事务：要么完全执行，要么什么也不做。 事务：transaction，执行单个逻辑功能的一组指令或操作。 提交：committed，已成功完成执行的终止事务。否则，称为撤销aborted。回退 rolled back。 调度：执行顺序。串行调度：每个事务原子地执行的调度。非串行调度：允许两个事务重叠执行。冲突可串行化：如果调度S通过一系列非冲突操作的交换而转换成串行调度S’，则调度S为冲突可串行化的。冲突操作：读写，写读，写写？ 加锁协议：（1）共享，可读，不能修改。（2）排他，可读可写。 两端加锁协议：（1）增长阶段，事务可获取锁，但不能释放锁。（2）收缩阶段，事务科释放锁，但不能获取新锁。 时间戳：对于系统内的每个事务Ti，都为之关联一个唯一固定的时间戳，并记为TS(Ti)。 （具体的是在数据库里学的） chapter7 死锁 死锁：deadlocked，两个或多个进程无限地等待一个时间，而该事件只能由这些等待进程之一来产生。/ 某个进程申请资源，如果这时资源不可用，那么该进程进入等待状态，如果所申请的资源被其他等待进程占有，那么该等待进程有可能再也无法改变其状态。 正常操作模式：①申请，如果申请不能立即被允许，那么申请进程必须等待，直到它获得资源为止。②使用，进程对资源进行操作。③释放，进程释放资源。 死锁的必要条件：①互斥。至少有一个资源必须处于非共享模式，即一次只有一个进程使用。如果另一个进程申请该资源，那么申请进程必须等到该原被释放为止。②占有并等待。一个进程必须占有至少一个资源，并等待另一资源，而该资源为其他进程所占有。③非抢占。资源不能被抢占，即资源只能在进程完成任务后自动释放。④循环等待。有一组等待进程{P0,P1,..,Pn}，P0等待的资源为P1所占有，..，Pn等待的资源为P1所占有。所有4个条件同时满足才会出现死锁。条件并不完全独立。 资源分配图：如果分配图没有环，那么系统就没有进程死锁。如果分配图有环，那么可能存在死锁。如果每个资源类型刚好有一个实例，那么有环就以为这已经出现死锁。如果环涉及一组资源类型，而每个类型只有一个实例，那么就出现死锁。 处理死锁：（1）可使用协议以预防或避免死锁，确保系统不会进入死锁状态。（2）可允许系统进入死锁状态，然后检测它，并加以恢复。（3）可忽视这个问题，认为死锁不可能在系统内发生。 死锁预防：deadlock revention，是一组方法，以确保至少一个必要条件不成立。 死锁避免：deadlock avoidance，要求操作系统事先得到有关进程申请资源和使用资源的额外信息。有了额外信息，系统可确定，对于一个申请，进程是否应等待。 如果不采用死锁预防和避免，系统可提供一个算法来检查系统状态以确定死锁是否发生，并提供另一个算法来从死锁恢复。 死锁预防：（1）互斥。非共享资源要有互斥条件。通常不能通过否定互斥条件来预防死锁，有的资源本身就是非共享的。（2）占有并等待。当一个进程申请一个资源时，它不能占有其他资源。①每个进程在执行前申请并获得所有资源。②允许进程在没有资源时才可申请资源。两种方法资源利用率低，可能发生饥饿。（3）非抢占。如果一个进程占有资源并申请另一个不能立即分配的资源，那么其现已分配的资源都可被抢占。（4）循环等待。对所有资源类型进行完全排序，且要求每个进程按递增顺序来申请资源。（低设备使用率，低系统吞吐率） 死锁避免：获得以后如何申请资源的附加信息。（1）安全状态。如果存在一个安全序列，那么系统处于安全状态。进程顺序&lt;P1,P2,..,Pn&gt;，如果对于每个Pi，Pi仍然可以申请的资源数小于当前可用资源加上所有进程Pj(j&lt;i)所占有的资源，则为安全序列。安全状态不是死锁状态，死锁状态是不安全状态。（2）资源分配图算法。引入需求边，虚线表示。检测环。（3）银行家算法。系统进程个数n，资源类型的种类m，Available[j]=k资源类型Rj现有k个实例，Max ij=k进程Pi最多可申请k个资源类型Rj的实例，Allocation ij=k进程Pi现在已分配了k个资源类型Rj的实例，Need ij=k进程Pi还可能申请k个资源类型Rj的实例。 死锁检测：（1）每种资源类型只有单个实例。等待图，从资源分配图中，删除所有资源类型节点，合并适当边，就可以得到等待图。当且仅当等大图中有一个环，系统中存在死锁。（2）每种资源类型可有多个实例。与银行家算法类似。Available，Allocation，Request。 死锁恢复：（1）进程终止。终止所有死锁进程，一次只终止一个进程直到取消死锁循环为止。（2）资源抢占。（选择一个牺牲品，回滚，饥饿） chapter8 内存管理 CPU能直接访问的存储器：内存，处理器内的寄存器。 地址绑定：（1）编译时，绝对代码。（2）加载时，可重定位代码。（3）执行时。 逻辑地址：CPU所生成的地址。物理地址：内存单元所看到的地址。 运行时从虚拟地址到物理地址的映射是由被称为内存管理单元MMU的硬件设备来完成的。 进程可以暂时从内存中交换到备份存储上，当需要再次执行时再调回到内存中。一个交换出的进程需要交换回它原来所占有的内存空间。（1）如果绑定是在汇编时或加载时所定的，那么就不可以移动到不同的位置。（2）如果绑定在运行时才确定，由于物理地址是在运行时才确定的，那么进程可以移到不同的地址空间。交换需要备份存储，通常是快速磁盘。 内存映射：重定位寄存器含有最小的物理地址值，界限地址寄存器含有逻辑地址的范围值。 内存分配：分区，最简单，将内存分为多个固定大小的分区，每个分区只能容纳一个进程。 可变分区。操作系统有一个表，用于记录哪些内存可用和哪些内存已被占用。孔hole，一大块可用内存。找足够大的孔，孔内未分配的内存可以下次使用。新进程需要内存时，查找足够大的孔，如果孔太大则分为两块，一块给新进程，另一块还给孔。进程终止时释放内存还给孔集合。如果新孔和其他孔相邻，则合并。选孔：①首次适应，分配第一个足够大的孔。②最佳适应，分配最小的足够大的孔。③最差适应，分配最大的孔。 外部碎片问题，首次适应和最佳适应都有。50%规则，假定有N个可分配块，那么可能有0.5N个块为外部碎片。 内部碎片问题，内存按固定大小分配，在分区内，但不能使用。 解决外部碎片的问题：（1）紧缩，移动内存内容，以便使所有空闲空间合并成一整块。如果重定位是静态的，并且在汇编时或装入时进行的，那么就不能紧缩。（2）允许物理地址空间为非连续。 分页：允许进程的物理地址空间可以是非连续的。基本方法：将物理内存分为固定大小的块（帧）。将逻辑内存分为同样大小的块（页）。由CPU生成的每个地址分为两个部分：页号p和页偏移d。页表包含每页所在物理内存的基地址。采用分页技术不会产生外部碎片，会有内部碎片。 页表的硬件实现：一组专用寄存器，转换表缓冲区TLB。TLB只包括页表的一小部分条目，当CPU产生逻辑地址后，其页号交给TLB，如果找到…，如果不在TLB中，就需要访问页表…。 分页下的内存保护：通过与每个帧相关联的保护胃来实现。一个位定义可读写还是只读。 如果代码是可重入代码，则可以共享。不能自我修改的代码。 层次页表：外页表-&gt;页表-&gt;内存 哈希页表：以虚拟页码作为哈希值，每个元素三个域，虚拟页码、所映射的帧号、指向链表中下一个元素的指针。虚拟地址中的虚拟页号转换到哈希表中，用虚拟页号与链表中的下一个元素的第一个域相比，如果皮诶，那么相应的帧号就用来形成物理地址，如果不匹配，就对下一个节点进行比较。 反向页表：△ 分段：支持用户视角的内存管理方案。逻辑地址空间是由一组段组成的，每个段都有名称和长度，地址指定了段名称和段内偏移。段表：段基地址，段界限。逻辑地址：段号，段内偏移。 chapter9 虚拟内存 虚拟内存：将用户逻辑内存与物理内存分开。 按需调页：在需要时才调入相应的页。懒惰交换：只有在需要页时，才将它调入内存。交换程序对整个进程进行操作，调页程序只对进程的单个页进行操作。 写时复制：如果任何一个进程需要对页进行写操作，那么就创建一个共享页的副本。 基本页置换：如果没有空闲帧，就查找当前没有使用的帧，并将其释放（将其内容写到交换空间，并改变页表以表示该页不在内存中）。①查找所需页在磁盘上的位置。②查找一个空闲帧。a.如果有空闲帧，就使用它。b.如果没有空闲帧，就使用页置换算法以选择一个牺牲帧。c.将牺牲帧的内容写到磁盘上，改变页表和帧表。③将所需页读入空闲帧，改变页表和帧表。④重启用户进程。 可以通过修改位或脏位以降低额外开销。如果修改位没有设置，那么就知道自从磁盘读入后该页没有发生修改，磁盘上页的副本的内容没有必要重写。 FIFO置换：为每个页记录着该页调入内存的时间。当必须置换一页时，将选择最旧的页。 Belady异常：对有的页置换算法，页错误率可能会随着所分配的帧数的增加而增加，而原期望为进程增加内存会改善其性能。 最优置换：置换最长时间不会使用的页。无Belady异常。 LRU算法：最近最少使用，选择最长时间没有使用的页。（计数器，栈）无Belady异常。 近似LRU页置换：引用位，（1）附加引用位，（2）二次机会算法，FIFO，检查引用位，0直接置换，1给第二次机会。（3）增强型二次机会算法，引用位和修改位，(0,0)最近没有使用且没有修改，(0,1)最近没有使用但修改过，(1,0)最近使用过但没被修改，(1,1)最近使用过且被修改过。 基于计数的：最不经常使用，最常使用。 页缓冲：维护一个已修改页的列表，每当调页设备空闲时，就选择一个修改页并写到磁盘上，接着重新设置其修改位；保留一个空闲帧池，但要记住哪些页在哪些帧中。 帧分配：全局置换，允许一个进程从所有帧集合中选择一个置换帧；局部置换，每个进程仅从其自己的分配帧中进行选择。 系统颠簸：thrashing，频繁的页调度。 预调页：同时将所需要的所有页一起调入到内存中。 chapter10 文件系统接口 文件：记录在外存上的相关信息的具有名称的集合。是逻辑外村的最小分配单元。 顺序访问： 直接访问/相对访问：文件由固定长度的逻辑记录组成，以允许程序按任意顺序进行快速读和写。 存储结构：分区（目录，文件） 单层结构目录：所有文件包含在同一目录中，便于理解和支持。必须具有唯一名名称。 双层结构目录：主文件目录，用户文件目录。 树状结构目录：绝对路径名：从根开始并给出路径上目录名直到所指定的文件；相对路径名：从当前目录开始定义路径。禁止共享文件和目录。 无环图目录：允许目录含有共享子目录和文件，同一文件或子目录可出现在两个不同目录中，无环图是树状结构目录方案的扩展。 通用图目录： chapter11 文件系统实现 应用程序-&gt; 逻辑文件系统-&gt; 文件组织系统-&gt; 基本文件系统-&gt; I/O控制-&gt; 设备 文件组织模块知道文件及其逻辑块和物理块。可以将逻辑块地址转换成基本文件系统所用的物理块地址。 文件系统实现包括三个主要层次：（1）文件系统接口，open() read() write() close()调用以及文件描述符。（2）虚拟文件系统层，VFS：定义一个清晰的VFS接口，以将文件系统的通用操作和具体实现分开。提供了在网络上唯一标识一个文件的机制。（3）实现文件系统类型或远程文件系统协议。 目录实现：（1）线性列表：使用存储文件名和数据块指针的线性列表。（2）哈希表：根据文件名得到一个值，并返回一个纸箱线性列表中元素的指针。 主要磁盘空间分配方法：（1）连续，要求每个文件在磁盘上占有一组连续的块，用于访问连续分配文件所需要的寻道数最小，在确实需要寻道时所需要的寻道时间最小；支持顺序访问和直接访问。（2）链接。解决了连续分配的所有问题，采用链接分配，每个文件是磁盘块的链表，磁盘块分布在磁盘的任何地方。目录包括文件第一块的指针和最后一块的指针。只要有空闲块，文件就可以增大，无需合并磁盘空间。缺点：只能有效地用于文件的顺序访问，指针需要空间（将多个块组成簇，增加内部碎片），可靠性低。文件分配表FAT，每个卷开始部分用于存储FAT。（3）索引。通过把所有指针放在一起，通过索引块解决了这个问题。没有外部碎片问题。 空闲空间管理：（1）位向量（2）链表（3）组（4）计数 效率：取决于所使用的磁盘分配和目录管理算法。 恢复：一致性检查程序，备份和恢复 chapter12 大容量存储器的结构 磁盘：磁头，磁臂，磁道，扇区，柱面。 磁盘速度：传输速率（在驱动器和计算机之间的数据传输速率）+定位时间/随机访问时间（寻道时间(移动磁臂到所要的柱面所需时间)+旋转等待时间(等待所要的扇区旋转到磁臂下所需时间)） 磁头碰撞：虽然磁盘片上涂了一层薄的保护层，但是磁头还是可能损坏磁盘表面。 磁带：主要用于备份，速度慢，存储长久。 现代磁盘驱动器：一个一维的逻辑块的数组，逻辑块是最小的传输单位。按顺序映射到磁盘的扇区，先按磁道内扇区顺序，再按柱面内磁道顺序，最后按从外到内的柱面顺序来排序。 磁盘存储：（1）I/O端口或主机附属存储。（2）分布式文件系统的远程主机/网络附属存储。缺点：存储I/O操作需要使用数据网络的带宽，因此增加了网络通信延迟。 磁盘调度：（1）FCFS，先来先服务。（2）SSTF，最短寻道时间优先，在将磁头一道远处以处理其他请求之前，先处理靠近当前磁头位置的请求。（3）SCAN，电梯算法，磁臂从磁盘的一端向另一端移动，同时当磁头移过每个柱面时，处理位于该柱面上的服务请求。当到达另一端时，磁头改变移动方向，处理继续。（4）C-SCAN，提供一个更为均匀的等待时间，将磁头从磁盘一端移到磁盘的另一端，随着移动不断地处理请求。不过当磁头移到另一端时，它会马上返回到磁盘的开始，返回时不处理请求。（5）LOOK，磁头只移动到一个方向上最远的请求为止。C-LOOK RAID： chapter13 I/O输入系统 总线：一组线和一组严格定义的可以描述在线上传输信息的协议。 控制器：用于操作端口、总线或设备的一组电子器件。 轮询，中断，直接内存访问， 缓冲区：用来保存两个设备之间或在设备和应用程序之间所传输数据的内存区域。（速度差异，协调传输数据大小不一致，支持应用程序I/O的复制语义） 假脱机：Spooling，用来保存设备输出的缓冲区。 chapter14 保护 最小特权原则。 访问矩阵]]></content>
      <tags>
        <tag>study</tag>
        <tag>operating system</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode]1 Two Sum/两数之和]]></title>
    <url>%2F2018%2F08%2F02%2FLeetCode-1-Two-Sum-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C%2F</url>
    <content type="text"><![CDATA[写在最前面： 最近开始刷LeetCode上的题目了，做个记录吧，希望刷完之后自己的代码水平能有所提升。 之前都是习惯用JAVA写，但是C++也要练，同时还要注意时间复杂度，之前都没有做好。 ★ Two Sum Given an array of integers, return indices of the two numbers such that they add up to a specific target. You may assume that each input would have exactly one solution, and you may not use the same element twice. 两数之和 给定一个整数数组和一个目标值，找出数组中和为目标值的两个数。 你可以假设每个输入只对应一种答案，且同样的元素不能被重复利用。 1234给定 nums = [2, 7, 11, 15], target = 9因为 nums[0] + nums[1] = 2 + 7 = 9所以返回 [0, 1] 对于这个题目，首先想到的是暴力搜索，但是时间复杂度很高，为O(n^2) 。 另一个想法是，遍历一个数字，用目标去减得到另一个数字，查找这个数字是否存在。其中需要解决的是：1、查找，采用HashMap将数与位置映射起来（HashMap是常数级的查找效率 ） 2、重复，需要记录位置信息，两个不能一样。 java： 12345678910111213141516public int[] twoSum(int[] nums, int target) &#123; HashMap&lt;Integer, Integer&gt; m = new HashMap&lt;Integer, Integer&gt;();//映射 int[] res = new int[2];//存放结果 for (int i = 0; i &lt; nums.length; ++i) &#123; m.put(nums[i], i); &#125; for (int i = 0; i &lt; nums.length; ++i) &#123; int t = target - nums[i]; if (m.containsKey(t) &amp;&amp; m.get(t) != i) &#123; res[0] = i; res[1] = m.get(t); break; &#125; &#125; return res;&#125; （感觉这个映射，Integer，如果值相同，只能记录一个位置，最后的） C++： 12345678910111213141516vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) &#123; unordered_map&lt;int, int&gt; m; vector&lt;int&gt; res; for (int i = 0; i &lt; nums.size(); ++i) &#123; m[nums[i]] = i; &#125; for (int i = 0; i &lt; nums.size(); ++i) &#123; int t = target - nums[i]; if (m.count(t) &amp;&amp; m[t] != i) &#123; res.push_back(i); res.push_back(m[t]); break; &#125; &#125; return res;&#125; C++用得不是很熟，hashmap不大会，还有vector用得也不多，希望多写写熟练一下。]]></content>
      <tags>
        <tag>study</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[随笔]]></title>
    <url>%2F2018%2F08%2F02%2F%E9%9A%8F%E7%AC%94%2F</url>
    <content type="text"><![CDATA[最近很忙也很累，是我有史以来最忙的一个暑假了，但是想想就觉得自己在大一大二的时候浪费了很多时间，光顾着玩去了，-_-|| 等忙结束了，想着把大数据最后一个实验（推荐系统）完善一下，做点记录，逼自己开个坑，一定要完成，不能偷懒，以前的话，总是想做什么，嗯，当时很想，结果后来就想着算了吧 深感自己的各方面不足，思维模式还是停留在很久以前，写代码方面实在是太弱了 追 101 的时候遇到了一位七家的大佬，做的数据对比的网站，实在是羡慕 https://101.tuimeizi.cn/ https://data.laimeiyun.cn/#/ 也算是燃起了我的斗志吧 暂时先写这么多了]]></content>
      <tags>
        <tag>7788</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hadoop-k_means算法的并行化&非并行化实现]]></title>
    <url>%2F2018%2F06%2F09%2FHadoop-k-means%E7%AE%97%E6%B3%95%E7%9A%84%E5%B9%B6%E8%A1%8C%E5%8C%96-%E9%9D%9E%E5%B9%B6%E8%A1%8C%E5%8C%96%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[实 验 内 容 自 行 准 备 数 据 集 ， 设 计 一 个 数 据 挖 掘 算 法 （ 聚 类 、 分 类 、 频 繁 项 集 挖 掘 或 其 他主 题 ） 对 数 据 集 进 行 信 息 提 取 ， 要 求 分 别 使 用 并 行 化 和 非 并 行 化 的 方 式 实 现 该 算法 。 实 验 要 求 自 行 对 比 并 行 化 和 非 并 行 化 实 现 方 法 的 数 据 挖 掘 结 果 ， 两 种 结 果 需 完 全 一致 。 有用的参考链接： UCI数据集 MapReduce Kmeans聚类算法 （java）K-means算法 我选择实现的是k_means聚类算法。 首先是数据集，我用的是UCI的wine.data，可以点击查看数据集的信息，右键目标另存为直接down下来。 k_means算法的思想： 1）从N个文档随机选取K个文档作为质心 2）对剩余的每个文档测量其到每个质心的距离，并把它归到最近的质心的类。距离采用标准化欧式距离公式计算。 3）重新计算已经得到的各个类的质心 4）迭代2～3步直至新的质心与原质心相等或小于指定阈值，算法结束 并行化实现 combiner可以省略，直接reduce。 非并行化实现思路相同。 数据结构 12345678910//中心集合ArrayList&lt;ArrayList&lt;Double&gt;&gt; centers = new ArrayList&lt;ArrayList&lt;Double&gt;&gt;();//allArrayList&lt;ArrayList&lt;Double&gt;&gt; wines = new ArrayList&lt;ArrayList&lt;Double&gt;&gt;();//距离最近的ArrayList&lt;ArrayList&lt;Double&gt;&gt;[] cluster;//用k个中心int k = 0;//迭代次数int count = 0; 读取wine.data文件 1234567891011121314151617181920212223public k_means3(String path) &#123; //read file try &#123; BufferedReader reader = new BufferedReader(new FileReader(new File(path))); String s = null; while((s = reader.readLine())!=null)&#123; ArrayList&lt;Double&gt; temp = textToArray(s); wines.add(temp); &#125; &#125; catch (Exception e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125;public static ArrayList&lt;Double&gt; textToArray(String text)&#123; ArrayList&lt;Double&gt; list = new ArrayList&lt;Double&gt;(); String[] fileds = text.toString().split(","); for(int i=0; i&lt;fileds.length; i++)&#123; list.add(Double.parseDouble(fileds[i])); &#125; return list;&#125; 设置K和初始中心点 12345678910111213141516171819202122232425262728public void intialCenters() &#123; int length = wines.size(); int dis = length/k; for(int i=0; i&lt;k; i++)&#123; //初始中心 //wineCenter[i]=wineAll.get(dis*i); ArrayList&lt;Double&gt; tmp = wines.get(i*dis); centers.add(tmp); &#125; System.out.println("K是："+k+"\n初始确定的中心点是："); for (int i = 0; i &lt; k; i++) &#123; //double[] dou = centers.get(i); for (int j = 0; j &lt; 14; j++) &#123; double x = centers.get(i).get(j); System.out.print(x+" "); &#125; System.out.println(); &#125; System.out.println();&#125;public void setK(int k)&#123; this.k = k; cluster = new ArrayList[k]; for(int i=0; i&lt;k; i++) &#123; cluster[i] = new ArrayList&lt;ArrayList&lt;Double&gt;&gt;(); &#125; &#125; 计算过程 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798 public void work() &#123; calcu(); //完成输出 //中心点 for(int i=0; i&lt;k; i++) &#123; int size6 = centers.get(0).size(); for(int j=1; j&lt;size6; j++) &#123; System.out.print(centers.get(i).get(j)+" "); &#125;System.out.println(); &#125;System.out.println(); // PrintStream ps;try &#123; ps = new PrintStream("/home/huii/Desktop/kmeans2.txt"); System.setOut(ps); for(int i=0; i&lt;k; i++) &#123; int size2 = cluster[i].size(); int size3 = cluster[i].get(0).size(); for(int j=0; j&lt;size2; j++) &#123; double t = i+1; System.out.print(t+" "); for(int z=0; z&lt;size3; z++) &#123; System.out.print(cluster[i].get(j).get(z)+" "); &#125;System.out.println(); &#125; &#125;&#125; catch (FileNotFoundException e) &#123; // TODO Auto-generated catch block e.printStackTrace();&#125; &#125; public void calcu() &#123; boolean finish = false; //距离最近的 for(int i=0; i&lt;wines.size(); i++) &#123; int kind = 0; double mindis = Double.MAX_VALUE; for(int j=0; j&lt;k; j++) &#123; double dis = 0; int size4 = wines.get(0).size(); for(int z=0; z&lt;size4; z++) &#123; double a = wines.get(i).get(z); double b = centers.get(j).get(z); dis += Math.pow((b-a)/(b+a), 2); &#125; if(dis&lt;mindis) &#123; mindis = dis; kind = j; &#125; &#125; ArrayList&lt;Double&gt; tmp2 = wines.get(i); cluster[kind].add(tmp2); &#125; //重新计算中心 ArrayList&lt;ArrayList&lt;Double&gt;&gt; newlist = new ArrayList&lt;ArrayList&lt;Double&gt;&gt;(); for(int m=0; m&lt;k; m++) &#123; ArrayList&lt;Double&gt; newc = new ArrayList&lt;Double&gt;(); int size5 = cluster[m].get(0).size(); for(int n=0; n&lt;size5; n++) &#123; //每列平均值 double sum = 0; int size = cluster[m].size(); for(int c=0; c&lt;size; c++) &#123; sum += cluster[m].get(c).get(n); &#125; newc.add(sum/size); &#125; newlist.add(newc); //ArrayList&lt;Double&gt; oldlist = cluster[k].get(index); &#125; //比较前后中心是否相同，判断迭代是否结束 int size1 = centers.size(); int fildsize = centers.get(0).size(); double cdis = 0; for(int l=0; l&lt;size1; l++) &#123; for(int o=0; o&lt;fildsize; o++) &#123; double t1 = centers.get(l).get(o); double t2 = newlist.get(l).get(o); cdis += Math.pow((t1-t2)/(t1+t2), 2); &#125; &#125; if(cdis == 0.0) finish = true; System.out.println(count); count++; if(!finish) &#123; //没完成 centers.clear(); for(int j=0; j&lt;k; j++)&#123; centers.add(newlist.get(j)); cluster[j].clear(); &#125; calcu(); &#125; &#125; 结果： 第一列是所属的类别，第二列往后是各行的数据。 实现后，发现要完全一致，大致看了一下，结果是对的，但是顺序不一样，(ó﹏ò｡)，不知道为什么MapReduce的输出顺序跟我想的不一样？？ 非并行化的顺序是按照类别，类别中再按照数据集的顺序。 为了顺序输出，我在map中添加： 1234567891011121314ArrayList&lt;ArrayList&lt;Double&gt;&gt; wines = new ArrayList&lt;ArrayList&lt;Double&gt;&gt;();if(flag) &#123; ArrayList&lt;Double&gt; x = new ArrayList&lt;Double&gt;(); String[] tmp = value.toString().split(","); //System.out.print((centerIndex+1)+" "); double index = centerIndex+1; x.add(index); for(int i=0; i&lt;tmp.length; i++) &#123; //System.out.print(tmp[i]+" "); double y = Double.parseDouble(tmp[i]); x.add(y); &#125;//System.out.println(); wines.add(x);&#125; 添加cleanup方法 123456789101112131415161718protected void cleanup(Context context) throws IOException, InterruptedException &#123; if(flag) &#123; PrintStream ps = new PrintStream("/home/huii/Desktop/kmeans1.txt");//创建一个打印输出流，输出的目标是 System.setOut(ps);//把创建的打印输出流赋给系统。即系统下次向 ps输出 int size1 = wines.size(); for(int i=1; i&lt;k+1; i++) &#123; for(int j=0; j&lt;size1; j++) &#123; if(wines.get(j).get(0) == i) &#123; int size2 = wines.get(j).size(); for(int m=0; m&lt;size2; m++) &#123; System.out.print(wines.get(j).get(m)+" "); &#125;System.out.println(); &#125; &#125; &#125; &#125; &#125; 嘻嘻嘻٩(๑&gt;◡&lt;๑)۶]]></content>
      <tags>
        <tag>study</tag>
        <tag>hadoop</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法—-局部搜索算法]]></title>
    <url>%2F2018%2F05%2F27%2F%E7%AE%97%E6%B3%95-%E5%B1%80%E9%83%A8%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[要求： 生成一个无向连通图，有100个点，1000条边，边上的权重是1到20之间的随机整数。 用局部搜索算法实现，再用Kruskal或prim算法进行验证。 局部搜索算法的基本思路： 设法得到一棵生成树T 检查不在T上的边，如果加上一条边，生成一个环，并删除一条环上的最大权重的边 重复2，直到所有边都不能优化为止。 对于以上要求和思路，我们可以一步一步地实现： 生成无向连通图 这里，我采用链表的形式存储。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178struct Node &#123;//链表节点 Node(int x, int y, int z, int q); int vseq;//x int vseq2;//为了记录边增加的属性，q int eseq;//z int weight;//权重1-20,y Node *next;&#125;;Node::Node(int x, int y, int z, int q) &#123; vseq = x; vseq2 = q; weight = y; eseq = z; next = NULL;&#125;class List &#123;public: List(); bool Find(int x);//找点 bool Finde(int z);//找边 int finde(int x, int y);//根据点得到边序号和权重 void PushBack(int x, int y, int z, int q); void Sort(); void PrintList(); void MovNode(Node *p);//delete the node which data=x void PopBack(); void PopFront(); int count; Node* head; Node* tail;&#125;;List::List() &#123; head = NULL; tail = NULL; count = 0;&#125;bool List::Find(int x) &#123; if (head == NULL) &#123; //cout &lt;&lt; "empty" &lt;&lt; endl; return false; &#125; else &#123; Node* p = head; while (p != NULL) &#123; if (p-&gt;vseq == x) return true; p = p-&gt;next; &#125; return false; &#125;&#125;int List::finde(int x, int y) &#123; if (head == NULL) &#123; //cout &lt;&lt; "empty" &lt;&lt; endl; //return; &#125; else &#123; Node* p = head; while (p != NULL) &#123; if (p-&gt;vseq == x ) return p-&gt;eseq; p = p-&gt;next; &#125; //return;|| (p-&gt;vseq2 == x &amp;&amp; p-&gt;vseq == y)&amp;&amp; p-&gt;vseq2 == y &#125;&#125;bool List::Finde(int z) &#123; if (head == NULL) &#123; //cout &lt;&lt; "empty" &lt;&lt; endl; return false; &#125; else &#123; Node* p = head; while (p != NULL) &#123; if (p-&gt;eseq == z) return true; p = p-&gt;next; &#125; return false; &#125;&#125;void List::PushBack(int x, int y, int z, int q) &#123; if (head == NULL) &#123; head = new Node(x, y, z, q); tail = head; &#125; else &#123; tail-&gt;next = new Node(x, y, z, q); tail = tail-&gt;next; &#125; count++;&#125;void List::Sort() &#123; int temp; if (head == NULL) return; for (int i = 0; i &lt; count - 1; i++) &#123; Node* left = head; Node* right = head-&gt;next; if (left-&gt;vseq &gt; right-&gt;vseq) &#123; temp = left-&gt;vseq; left-&gt;vseq = right-&gt;vseq; right-&gt;vseq = temp; &#125; right = right-&gt;next; left = left-&gt;next; &#125;&#125;void List::PrintList() &#123; if (head == NULL) &#123; cout &lt;&lt; "empty" &lt;&lt; endl; return; &#125; else &#123; Node* tmp = head; while (tmp != NULL) &#123; cout &lt;&lt; "--&gt;" &lt;&lt; tmp-&gt;vseq; cout &lt;&lt; "," &lt;&lt; tmp-&gt;weight; tmp = tmp-&gt;next; &#125; cout &lt;&lt; endl; &#125;&#125;void List::MovNode(Node *p) &#123; if (p == tail) &#123; PopBack(); &#125; else if (p == head) &#123; PopFront(); &#125; else &#123; Node *pp = head; while (pp-&gt;next != p) &#123; pp = pp-&gt;next; &#125; pp-&gt;next = p-&gt;next; delete p; &#125; count--;&#125;void List::PopBack() &#123; if (head == NULL) &#123; //cout &lt;&lt; "empty" &lt;&lt; endl; //return; &#125; else if (head == tail) &#123; delete head; head = NULL; tail = NULL; &#125; else &#123; Node* cur = head; while (cur-&gt;next != tail) &#123; cur = cur-&gt;next; &#125; delete tail; tail = cur; tail-&gt;next = NULL; &#125;&#125;void List::PopFront() &#123; if (head == NULL) &#123; //cout &lt;&lt; "empty" &lt;&lt; endl; return; &#125; Node* tmp = head; head = head-&gt;next; tail-&gt;next = NULL; delete tmp;&#125; 需要的存储结构 123456789101112131415161718192021222324252627282930313233343536struct Edge &#123;//链表节点 //Node(int x, int y, int z, int q); int vseq;//x int vseq2;//为了记录边增加的属性，q int eseq;//z int weight;//权重1-20,y //Node *next;&#125;;struct Vertex &#123;//顶点 //Vertex(int x); int seq;//0-99 int color;//whilte-0,gray-1,black-2 int d;//discovet time int f;//finish time int parent;//π //Vertex *next; bool has = false;//是否有邻接点进栈 //int set = V;&#125;;List e[V];//100个点，每个点一个链表List e2[V];//找环的链表Edge e3[E];//存储边的信息，找权重Vertex v[V];//dfsVertex v2[V];//circleint t = 0;//timestack&lt;Vertex&gt; st;//DFSstack&lt;Vertex&gt; st2;//找环的DFSVertex tmp;//topNode *p = NULL;//headint pp = 0;//p.seqNode *ppp = NULL;int countt = 0;List tree;//生成树List cir;//求环stack&lt;Edge&gt; ntree;//不在树上Node *l; 随机生成无向图 12345678910111213141516171819202122232425262728293031323334353637int randomnum()//返回一个0-99之间的随机数&#123; int a; //srand(0);//设置随机数种子，使每次运行获取的随机数不同 a = rand() % V; return a;&#125;int randomnum2()//返回一个0-19之间的随机数&#123; int b; //srand(0);//设置随机数种子，使每次运行获取的随机数不同 b = rand() % 20; b++; return b;&#125;//生成无向连通图void creDGra() &#123; //n个点，至少n-1条边 int a, b, c; //Node v[V];//100个点 for (int i = 0; i &lt; E; i++) &#123; a = randomnum(); b = randomnum(); c = randomnum2();//weight if (!e[a].Find(b) &amp;&amp; a!=b) &#123; e[a].PushBack(b,c,i,a); e[b].PushBack(a,c,i,b); e3[i].eseq = i; e3[i].vseq = a; e3[i].vseq2 = b; e3[i].weight = c; &#125; else &#123; i--; &#125; &#125;&#125; 找出一棵生成树T 这个利用DFS就可以实现，这里写的是利用栈实现的非递归DFS。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960//生成树void DFS() &#123;//not .. //cout &lt;&lt; "start with " &lt;&lt; s &lt;&lt; endl; //initialize for (int i = 0; i &lt; V; i++) &#123; v[i].seq = i; v[i].color = WHITE; v[i].d = -1; v[i].f = -1; v[i].parent = V; &#125; //push the first for (int s = 0; s &lt; V; s++) &#123; if (v[s].color == WHITE) &#123; //cout &lt;&lt; v[s].seq &lt;&lt; endl; v[s].color = GRAY; v[s].d = t; t++; st.push(v[s]); while (!st.empty()) &#123; tmp = st.top(); //cout &lt;&lt; tmp.seq &lt;&lt; " color:" &lt;&lt; tmp.color &lt;&lt; endl; if (v[tmp.seq].color == BLACK) &#123; st.pop(); &#125; //cout &lt;&lt; "top: " &lt;&lt; tmp.seq &lt;&lt; endl; //adjacent p = e[tmp.seq].head; for (int i = 0; i &lt; e[tmp.seq].count; i++) &#123; pp = p-&gt;vseq; //cout &lt;&lt; "list:" &lt;&lt; pp &lt;&lt; " "&lt;&lt;v[pp].color&lt;&lt;endl; if (v[pp].color == WHITE) &#123; tree.PushBack(pp, p-&gt;weight, p-&gt;eseq, tmp.seq); v[pp].color = GRAY; v[pp].d = t; t++; v[pp].parent = tmp.seq; st.push(v[pp]); p = p-&gt;next; tmp.has = true; break; &#125; else if (v[pp].color == GRAY) &#123; p = p-&gt;next; &#125; else if (v[pp].color == BLACK) &#123; p = p-&gt;next; &#125; &#125; if (!tmp.has) &#123; //cout &lt;&lt; tmp.seq &lt;&lt; " has " &lt;&lt; tmp.has &lt;&lt; endl; v[tmp.seq].color = BLACK; v[tmp.seq].f = t; t++; st.pop(); &#125; &#125; &#125; &#125;&#125; 得到不在树上的边 1234567void ninT() &#123;//在T上，不在T上，eseq判断 for (int i = 0; i &lt; E; i++) &#123; if (!tree.Finde(i)) &#123; ntree.push(e3[i]); &#125; &#125;&#125; 生成树的邻接链表 一开始我直接用的整个生成图的邻接链表去DFS找环，后来想想不对，因为不是所有的边都在那个数+边里。 12345678910111213141516171819202122//生成树的邻接链表void tlink() &#123; //intialize e2 or clear if (countt &gt; 1) &#123; for (int i = 0; i &lt; V; i++) &#123; for (int j = 0; j &lt; e2[i].count; j++) &#123; Node * kk = e2[i].head; e2[i].MovNode(kk); j--; //kk = kk-&gt;next; &#125; &#125; &#125; l = tree.head; for (int i = 0; i &lt; tree.count; i++) &#123; if (!e2[l-&gt;vseq].Find(l-&gt;vseq2)) &#123; e2[l-&gt;vseq].PushBack(l-&gt;vseq2, l-&gt;weight, l-&gt;eseq, l-&gt;vseq); e2[l-&gt;vseq2].PushBack(l-&gt;vseq, l-&gt;weight, l-&gt;eseq, l-&gt;vseq2); &#125; l = l-&gt;next; &#125;&#125; 找环 原来是一棵树，加上一条边，一定有一个环，且新加的这条边一定在环上。设这条新加的边为(a,b)，则以a为起始点做DFS，遇到第一条返回边时，这个环就找到了。（无向图只有树边和返回边） 在实现过程中，我先将新加的边加入到生成树中，再生成邻接链表，在DFS过程中，只记录返回边，环根据父节点可以得到。（从返回边的一端回溯，到另一端点，就能找出这个环） 得到了环之后，就可以找出环上权重最大的边删除。一直循环到所有不在T上的边都试了一次。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131//找环void findc() &#123; //加边 while (!ntree.empty()) &#123; countt++; //cout &lt;&lt; countt &lt;&lt; endl; //Node *r = ntree.top();//一条不在t的边 Edge r = ntree.top(); //---------------------------- tree.PushBack(r.vseq,r.weight,r.eseq,r.vseq2); tlink(); //dfs找环退出 //要按tree中的边dfs，不能按原来的 t = 0; for (int i = 0; i &lt; V; i++) &#123; v2[i].seq = i; v2[i].color = WHITE; v2[i].d = -1; v2[i].f = -1; v2[i].parent = V; &#125; //push the first //新加的边必定在环内，以该边的一点为dfs的起始点，找到返回边，说明有环 //无向图只有树边和返回边 //for (int s = 0; s &lt; V; s++) &#123; int s = r.vseq; if (v2[s].color == WHITE) &#123; //cout &lt;&lt; v[s].seq &lt;&lt; endl; v2[s].color = GRAY; v2[s].d = t; t++; st2.push(v2[s]); while (!st2.empty()) &#123; tmp = st2.top(); //cout &lt;&lt; tmp.seq &lt;&lt; " color:" &lt;&lt; tmp.color &lt;&lt; endl; if (v2[tmp.seq].color == BLACK) &#123; st2.pop(); &#125; //cout &lt;&lt; "top: " &lt;&lt; tmp.seq &lt;&lt; endl; //adjacent p = e2[tmp.seq].head; for (int i = 0; i &lt; e2[tmp.seq].count; i++) &#123; pp = p-&gt;vseq; //cout &lt;&lt; "list:" &lt;&lt; pp &lt;&lt; " "&lt;&lt;v[pp].color&lt;&lt;endl; if (v2[pp].color == WHITE) &#123; //tree.PushBack(pp, p-&gt;weight, p-&gt;eseq, tmp.seq); v2[pp].color = GRAY; v2[pp].d = t; t++; v2[pp].parent = tmp.seq; st2.push(v2[pp]); p = p-&gt;next; tmp.has = true; break; &#125; else if (v2[pp].color == GRAY) &#123; if (pp != v2[p-&gt;vseq2].parent) &#123; cir.PushBack(pp, p-&gt;weight, p-&gt;eseq, p-&gt;vseq2); &#125; p = p-&gt;next; //break; //continue; &#125; else if (v2[pp].color == BLACK) &#123; p = p-&gt;next; &#125; &#125; if (!tmp.has) &#123; //cout &lt;&lt; tmp.seq &lt;&lt; " has " &lt;&lt; tmp.has &lt;&lt; endl; v2[tmp.seq].color = BLACK; v2[tmp.seq].f = t; t++; //tmp.color = BLACK; //tmp.f = t; //t++; st2.pop(); &#125; &#125; &#125; //&#125; //--------------------------------------- //环 Node *u = cir.head; int k = L; int h = L; int w = L; while (k != s) &#123; k = v2[u-&gt;vseq2].parent; h = e[u-&gt;vseq2].finde(k, u-&gt;vseq2); w = e3[h].weight; //cout &lt;&lt; u-&gt;vseq2 &lt;&lt; " " &lt;&lt; k &lt;&lt; " " &lt;&lt; endl; cir.PushBack(u-&gt;vseq2,w,h,k); u = u-&gt;next; &#125; //----------------- //环中最大的 u = cir.head; //Node *m = u; int maxw = -1; int maxseq = u-&gt;eseq; for (int i = 0; i &lt; cir.count; i++) &#123; if (u-&gt;weight &gt; maxw) &#123; maxseq = u-&gt;eseq; maxw = u-&gt;weight; &#125; u = u-&gt;next; &#125; //--------------------- //删除最大的 u = tree.head; for (int i = 0; i &lt; tree.count; i++) &#123; if (u-&gt;eseq == maxseq) &#123; tree.MovNode(u); break; &#125; u = u-&gt;next; &#125; ntree.pop(); //------------ //intializa tree for (int j = 0; j &lt; cir.count; j++) &#123; Node * kk = cir.head; cir.MovNode(kk); j--; //kk = kk-&gt;next; &#125; &#125; &#125; 我选择用kruskal算法进行验证 重点是并查集find和unite的实现。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152int find(int x) &#123; int root = x; while (root != par[root]) root = par[root]; while (x != root) &#123; int t = par[x]; par[x] = root; x = t; &#125; return root;&#125;void unite(int x, int y) &#123; x = find(x); y = find(y); if (Rank[x] &lt; Rank[y]) &#123; par[x] = y; &#125; else &#123; par[y] = x; if (Rank[x] == Rank[y]) Rank[x]++; &#125;&#125;void mst_kruskal() &#123; for (int i = 0; i &lt; E; i++) &#123; e4[i] = e3[i]; //cout &lt;&lt; e4[i].vseq &lt;&lt; " " &lt;&lt; e3[i].vseq &lt;&lt; endl; &#125; for (int i = 0; i &lt; V; i++) &#123; //set[i].PushBack(); par[i] = i; Rank[i] = 0; &#125; Edge tempp; for (int i = 0; i &lt; E-1; i++) &#123; for (int j = i + 1; j &lt; E; j++) &#123; if (e4[i].weight &gt; e4[j].weight) &#123; tempp = e4[j]; e4[j] = e4[i]; e4[i] = tempp; &#125; &#125; &#125; for (int i = 0; i &lt; E; i++) &#123; int vv = e4[i].vseq; int uu = e4[i].vseq2; //cout &lt;&lt; vv &lt;&lt; " " &lt;&lt; v[vv].set &lt;&lt; " " &lt;&lt; uu &lt;&lt; " " &lt;&lt; v[uu].set &lt;&lt; endl; if (find(vv) != find(uu)) &#123; A.PushBack(vv,e4[i].weight, e4[i].eseq, uu); //v[uu].set = v[vv].set; unite(vv, uu); &#125; &#125;&#125; main函数 输出局部搜索算法和Kruskal算法的最小生成树的权重进行比较，如果相等，则证明正确。 123456789101112131415161718192021222324252627282930313233343536int main()&#123; creDGra(); for (int i = 0; i &lt; V; i++) &#123; cout &lt;&lt; i; e[i].PrintList(); &#125; cout &lt;&lt; "----------------------------" &lt;&lt; endl; DFS(); ninT(); findc(); cout &lt;&lt; "=============================" &lt;&lt; endl; int sum1 = 0; //tree.PrintList();//最小生成树 //---------------------- l = tree.head; for (int i = 0; i &lt; tree.count; i++) &#123; cout &lt;&lt; l-&gt;vseq &lt;&lt; " " &lt;&lt; l-&gt;vseq2 &lt;&lt; " " &lt;&lt; l-&gt;weight &lt;&lt; " " &lt;&lt; l-&gt;eseq &lt;&lt; endl; sum1 += l-&gt;weight; l = l-&gt;next; &#125; cout &lt;&lt; "局部搜索:";cout &lt;&lt; sum1 &lt;&lt; endl; //------------------------- cout &lt;&lt; "----------------------------" &lt;&lt; endl; int sum2 = 0; mst_kruskal(); l = A.head; for (int i = 0; i &lt; A.count; i++) &#123; sum2 += l-&gt;weight; cout &lt;&lt; l-&gt;vseq &lt;&lt; " " &lt;&lt; l-&gt;vseq2 &lt;&lt; " " &lt;&lt; l-&gt;weight &lt;&lt; " " &lt;&lt; l-&gt;eseq &lt;&lt; endl; l = l-&gt;next; &#125; cout &lt;&lt; "kruskal：" &lt;&lt; sum2 &lt;&lt; endl; getchar(); return 0;&#125; 结果截图 完成，✿✿ヽ(°▽°)ノ✿]]></content>
      <tags>
        <tag>study</tag>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hadoop-PageRank算法的MapReduce实现]]></title>
    <url>%2F2018%2F05%2F21%2FHadoop-PageRank%E7%AE%97%E6%B3%95%E7%9A%84MapReduce%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[在本次实验中，我是参考了PageRank算法的MapReduce实现 输入文本格式：网页+\t+该网页链接到的网页的集合（相互之间用英文逗号分开） 实验要求&amp;输出文本格式： PageRank算法思想： 如果网页T存在一个指向网页A的连接，则表明T的所有者认为A比较重要，从而把T的一部分重要性得分赋予A。这个重要性得分值为：PR（T）/L(T) 其中PR（T）为T的PageRank值，L(T)为T的出链数。 则A的PageRank值为一系列类似于T的页面重要性得分值的累加。 即一个页面的得票数由所有链向它的页面的重要性来决定，到一个页面的超链接相当于对该页投一票。一个页面的PageRank是由所有链向它的页面（链入页面）的重要性经过递归算法得到的。一个有较多链入的页面会有较高的等级，相反如果一个页面没有任何链入页面，那么它没有等级。 解决思路： 可以得到公式 PR(A)即A的PageRank值；d为阻尼因子，实验中给出为0.85；L(B)即B网站所有的出链数量（即B网站内的所有链接的数量）。 所以公式的意义是：A的PageRank值=（1-d）+d*（链接到A的所有网站的PR值/该网站的所有出链数量之和）。这里首次计算时为每个链接附上一个初始PR值，实验中给出为1.0。 下面举个例子，这样能更清楚地知道map和reduce的输入输出对应该怎么写。 1234A B,C,DB A,CC A,B,DD A,C 为了计算PR(A)，就要知道所有链接到A的网站，PR值及其出链数。在例子中，这些网站就是B,C,D， 所以要得到类似 B,PR(B),2 这种值，再加上记号表明这是B到A的，可以形成&lt;A, B,PR(B),2 &gt;。MapReduce中会将同一个key的分到一个reduce中，因此在处理key为A时，会有如下输入对： 123&lt;A, B,PR(B),2&gt;&lt;A, C,PR(C),3&gt;&lt;A, D,PR(D),2&gt; 就可以利用公式，计算出PR(A)。因为要进行迭代，所以还必须要有 A B,C,D 。 为了区分 ，将 B,PR(B),2 改为用 ; 分隔：B;PR(B);2。 初始值是1.0可以直接赋给网站，但是迭代中，要怎么获取网站当前的PR值呢？ 在reduce中已经计算出了PR(A)，我们可以将它加到key中输出作为下一次map的输入key：A,PR(A) TIPS： （1）根据分析，map第一次输入为A B,C,D，迭代中的输入为&lt;A,PR(A) , B,C,D&gt;，是否需要写2个map函数？ 答：可以只写一个map函数，在第一次中，可以利用KeyValueTextInputFormat，它将\t之前的作为key读入，为A；在迭代中读入的key为A,PR(A)。利用分隔符 , 可以得到相应的值。 （2）在实现中，所有与计算PR值有关的必须用double类型，因为要保留10位小数。 1234567891011121314151617181920212223242526272829303132333435363738394041424344private static final double d = 0.85;//阻尼系数 public static class Map extends Mapper&lt;Text, Text, Text, Text&gt;&#123; public void map(Text key, Text value, Context context) throws IOException, InterruptedException &#123; //输入文件格式： a b,c,d(first) 采用KeyValueTextInputFormat // a,pr b,c,d(next) String[] out = value.toString().split(",");//外链 String[] link = key.toString().split(",");//next double pr = 1.0;//初始pr值 if(link.length &gt; 1) &#123; //next pr = Double.parseDouble(link[1]); &#125; int outNum = out.length;//a的出链数 //输出格式&lt;a的各出链:b/c/d, a;pr;outNum&gt; for(String s: out) &#123; context.write(new Text(s), new Text(link[0]+";"+pr+";"+outNum)); &#125; //&lt;a, out&gt;以便迭代处理 context.write(new Text(link[0]), value); &#125; &#125; public static class Reduce extends Reducer&lt;Text, Text, Text, Text&gt; &#123; public void reduce(Text key, Iterable&lt;Text&gt; values, Context context) throws IOException, InterruptedException &#123; double pr = (double) (1.0-d);// PageRank值 String[] str; Text outLinks = new Text();// 记录该链接的所有出链信息 // 集合的数据位key的所有入链链接的page,rank,count值，以及key的所有出链信息 for (Text t : values) &#123; // 入链信息以';'分割，出链信息以','分割，以此区别 str = t.toString().split(";"); if (str.length == 3) &#123; // 计算key的rank值=(1-d)+d*key的入链rank值/其出链数 pr += Double.parseDouble(str[1]) / Integer.parseInt(str[2]) * d; &#125; else &#123; outLinks.set(t.toString()); //&lt;a, b,c,d&gt; &#125; &#125; context.write(new Text(key.toString() + "," + pr), outLinks); &#125; &#125; main函数中的迭代： 12345678910111213141516171819202122232425Configuration conf = new Configuration(); conf.set("fs.defaultFS", "hdfs://localhost:9000"); // 进行迭代的过程 for (int i = 0; i &lt; 10; i++) &#123; String[] otherArgs = new String[]&#123;"/user/pr/out"+i, "/user/pr/out"+(i+1)&#125;; if (otherArgs.length != 2) &#123; System.err.println("Usage: PageRank &lt;in&gt; &lt;out&gt;"); System.exit(2); &#125; Job job = Job.getInstance(conf, "PageRank"); job.setJarByClass(PageRank.class); job.setInputFormatClass(KeyValueTextInputFormat.class); job.setMapperClass(Map.class); job.setReducerClass(Reduce.class); //设置Map输出类型 job.setMapOutputKeyClass(Text.class); job.setMapOutputValueClass(Text.class); //设置Reduce输出类型 job.setOutputKeyClass(Text.class); job.setOutputValueClass(Text.class); FileInputFormat.addInputPath(job, new Path(otherArgs[0])); FileOutputFormat.setOutputPath(job, new Path(otherArgs[1])); //System.exit(job.waitForCompletion(true) ? 0 : 1); job.waitForCompletion(true); &#125; 到此，输出的结果为： 可以看到输出结果为：网站,PR 网站中的链接 与标准输出还有距离，因此，我添加了一对map和reduce用来标准化输出。 为了按照PR排列，结合reduce是按照key排列的，且顺序是从小到大，因此先将PR作为key，网站作为value。 又因为，在标准输出中，是按照PR从大到小进行排列。所以可以在PR前加个负号 - 。 12345678910111213141516171819202122232425//10次迭代后，按格式输出 要按pr值排序，保留10位小数 public static class FinMap extends Mapper&lt;Text, Text, DoubleWritable, Text&gt;&#123; public void map(Text key, Text value, Context context) throws IOException, InterruptedException &#123; // a,pr b,c,d(next) //String[] k = key.toString().split(","); //这样是从小到大排序 //context.write(new Text(String.format("%.10f", Double.parseDouble(k[1]))), new Text(k[0]); String line = key.toString(); String url = line.split(",")[0]; String pr = line.split(",")[1]; context.write(new DoubleWritable(-Double.valueOf(pr)), new Text(url)); &#125; &#125; public static class FinReduce extends Reducer&lt;DoubleWritable, Text, NullWritable, Text&gt; &#123; public void reduce(DoubleWritable key, Iterable&lt;Text&gt; values, Context context) throws IOException, InterruptedException &#123; for (Text value: values) &#123; Double pr = -Double.valueOf(key.toString()); String result = "(" + value.toString() + "," + String.format("%.10f", pr) + ")"; context.write(null, new Text(result)); &#125; &#125; &#125; 相应的，在main函数中添加： 1234567891011121314151617181920String[] otherArgs = new String[]&#123;"/user/pr/out"+10, "/user/pr/out"+11&#125;; if (otherArgs.length != 2) &#123; System.err.println("Usage: PageRank &lt;in&gt; &lt;out&gt;"); System.exit(2); &#125; Job job = Job.getInstance(conf, "PageRank"); job.setJarByClass(PageRank.class); job.setInputFormatClass(KeyValueTextInputFormat.class); job.setMapperClass(FinMap.class); job.setReducerClass(FinReduce.class); //设置Map输出类型 job.setMapOutputKeyClass(DoubleWritable.class); job.setMapOutputValueClass(Text.class); //设置Reduce输出类型 job.setOutputKeyClass(NullWritable.class); job.setOutputValueClass(Text.class); FileInputFormat.addInputPath(job, new Path(otherArgs[0])); FileOutputFormat.setOutputPath(job, new Path(otherArgs[1])); //System.exit(job.waitForCompletion(true) ? 0 : 1); job.waitForCompletion(true); 结果： ✿✿ヽ(°▽°)ノ✿]]></content>
      <tags>
        <tag>study</tag>
        <tag>hadoop</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hadoop-文档倒排索引算法实现]]></title>
    <url>%2F2018%2F05%2F13%2FHadoop-%E6%96%87%E6%A1%A3%E5%80%92%E6%8E%92%E7%B4%A2%E5%BC%95%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[关于Hadoop的安装以及实验一可以参考： Tiny_16 Hadoop学习 下面来看实验二：文档倒排索引算法实现（debug的过程还是挺艰辛的） 实验内容包括：（1）去除stop-words （2）统计单词在每篇文档中出现的频率 一开始的思路我是参考的Hadoop之倒排索引，感觉挺好的，但是做到后面发现有问题。 还是从头开始吧。 （1）首先是处理停用词表利用MapReduce的分布式缓存 12//添加停用词表job.addCacheFile(new Path("hdfs://10.102.0.197:9000/stop_words/stop_words_eng.txt").toUri()); 在一开始进行处理，所以在map函数中通过context来访问到缓存的文件，重写setup方法来进行初始化 。setup方法用于初始化，只会执行一次。将停用词表的每一个词读出存入set中。（感觉在reduce的setup方法中处理也可以） 123456789101112131415161718192021private Set&lt;String&gt; stopwords = new TreeSet&lt;String&gt;(); private URI[] file; public void setup(Context context) throws IOException, InterruptedException&#123; //初始化 只执行一次 Configuration conf = context.getConfiguration(); //获得停用词表 file = Job.getInstance(conf).getCacheFiles(); for (int i = 0; i &lt; file.length; i++)&#123; String line; Path pa = new Path(file[i].getPath()); BufferedReader br = new BufferedReader( new FileReader(pa.getName().toString())); while((line = br.readLine()) != null)&#123; StringTokenizer itr = new StringTokenizer(line); while (itr.hasMoreTokens())&#123; stopwords.add(itr.nextToken()); &#125; &#125; &#125; &#125; （2）分析MapReduce的输入、输出对。按照之前链接上的思路，与给的标准答案对比，会出现txt排序不正确的问题，因为MapReduce的默认排序是对key。因此必须将txt也作为reduce输入key的一部分。 map类：输入对&lt;offset, line&gt;，输出对 &lt; key txt, 1 &gt; tips：中间分隔符应该用ASCII表排在数字之前的符号，否则单个数字就会被排到后面去1234567891011121314151617181920212223//&lt;offset,line&gt;--&gt;&lt;word:txt,1&gt;private static final IntWritable one = new IntWritable(1);private Text key1 = new Text();//private Text value1 = new Text();private FileSplit split;@Overridepublic void map(Object key, Text value, Context context) throws IOException, InterruptedException &#123; split = (FileSplit) context.getInputSplit(); //StringTokenizer itr = new StringTokenizer(value.toString()); String[] itr = value.toString().split("\\W"); //[^a-zA-Z0-9] only letters for (String s : itr) &#123; s = s.toLowerCase(); if(!stopwords.contains(s) &amp;&amp; !s.equals("")) &#123; key1.set(s + " "+ split.getPath().getName()); //必须用空格作为分隔符吗？？ASCII //用：就会不对 //value1.set("1"); context.write(key1, one); &#125; &#125;&#125; 为了方便后面的计算频数，在map和reduce之间添加一个combine类，先将一个词在同一个txt的出现次数加起来。 12345678910111213141516171819202122232425262728public static class Combine extends Reducer&lt;Text, IntWritable, Text, IntWritable&gt;&#123; //private IntWritable value2 = new IntWritable(1); //private Text key2 = new Text(); //private Text value2 = new Text(); private IntWritable value2 = new IntWritable(); public void reduce(Text key, Iterable&lt;IntWritable&gt; values, Context context) throws IOException, InterruptedException&#123; int sum = 0;//frequence for(IntWritable val : values) &#123; sum += val.get(); &#125; /* int splitIndex = key.toString().indexOf(":"); value2.set(key.toString().substring(splitIndex+1)+","+sum);//txt,sum key.set(key.toString().substring(0, splitIndex));//word //key2.set(key.toString().substring(0, splitIndex));//word //String[] itr = key.toString().split(":"); //key2.set(itr[0]); //value2.set(itr[1]+","+sum); context.write(key, value2);//&lt;word:txt,"1"&gt; -&gt; &lt;word, txt,sum&gt; //value2.set(sum); //context.write(key, value2);//&lt;word:txt, 1&gt; -&gt; &lt;word:txt, sum&gt; * */ //这样文件的位置不对 所以key必须是&lt;word:txt&gt; value2.set(sum); context.write(key, value2); &#125; &#125; 因为当前key为word txt，为了将同一个word分到一个reduce上，需要自定义partioner类。 123456789 //所以为了将按word分到一起... public static class Partitioner extends HashPartitioner&lt;Text, IntWritable&gt;&#123; public int getPartition(Text key, IntWritable value, int numReduceTasks)&#123; String word = new String(); word = key.toString().split(" ")[0]; //=&gt; word return super.getPartition(new Text(word), value, numReduceTasks); &#125;&#125; 最后的reduce类：输入，输出&lt;word, ..(格式).&gt; 1234567891011121314151617181920212223242526272829303132333435public static class Reduce extends Reducer&lt;Text, IntWritable, Text, Text&gt; &#123; //&lt;word ,txt,sum&gt; -&gt; &lt;word, &lt;&gt;;&lt;&gt;&gt; × //change to &lt;word:txt, sum&gt; -&gt; &lt;word, &lt;&gt;;&lt;&gt;.&gt; private Text key3 = new Text(); private Text value3 = new Text(); private String cur = " ";//记录word private String list = "";//记录文件列表 private long total = 0; public void reduce(Text key, Iterable&lt;IntWritable&gt; values, Context context) throws IOException, InterruptedException &#123; int temp = 0; for(IntWritable val : values) &#123; temp += val.get(); &#125; if(!cur.equals((key.toString().split(" "))[0]) &amp;&amp; !cur.equals(" ")) &#123; //如果cur不等于当前的word,说明上一个已经结束，下一个开始 //输出上一个total list += "&lt;total,"+total+"&gt;."; context.write(new Text(cur), new Text(list)); //下一个初始化 list = ""; total = 0; &#125; cur = (key.toString().split(" "))[0]; list += "&lt;"+(key.toString().split(" "))[1]+","+temp+"&gt;;"; total += temp; &#125; public void cleanup(Context context) throws IOException, InterruptedException&#123; //释放 只执行一次 //最后一个word list += "&lt;total,"+total+"&gt;."; context.write(new Text(cur), new Text(list)); &#125; &#125; 在main方法中，要注意设置的map和reduce的输出和前面写的一样，否则会报错，(╥╯^╰╥) 还要注意的是上一个输出对和下一个输入对类型要一致，否则会报错。 由此，实验二结束，✿✿ヽ(°▽°)ノ✿]]></content>
      <tags>
        <tag>study</tag>
        <tag>hadoop</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello-world]]></title>
    <url>%2F2018%2F05%2F12%2FHello-world%2F</url>
    <content type="text"><![CDATA[博客终于搭好啦~撒花✿✿ヽ(°▽°)ノ✿ 顺便记录一下 （1）主题 （2）搭建过程中还出现了错误：用hexo new命令创建了一篇文章，为什么主页没有显示？感谢wxu小姐姐。好像是因为_config.yml中timezone:写了不存在的时区的问题，还有md格式要写对。 emmmm，突然发现评论还没有加，(╯‵□′)╯︵┻━┻]]></content>
      <tags>
        <tag>7788</tag>
      </tags>
  </entry>
</search>
